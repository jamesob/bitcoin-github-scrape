jonatack,2020-05-26 11:38:47,"Reviewers: This PR is being discussed in the review club at https://bitcoincore.reviews/19055\n\n(A `Review club` tag for this PR would be helpful to indicate that review notes and discussion are available there.)",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-633971712,633971712,
jonasschnelli,2020-05-26 12:02:08,"Some history for the context:\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014337.html\n* based on #10434",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-633981639,633981639,
sipa,2020-05-26 16:45:17,"@gzhao408 I think there is a bit of a miscommunication. The term ""rolling"" here just means efficient addition as well as deletion from the set being hashed. There is no actual window, as sets are unordered. Perhaps the term was chosen badly (which would be my fault).\n\nAll of LtHash, MuHash, and ECMH support incremental addition and deletion. The ""non-rolling"" mention in @fjahr's document refer",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-634142704,634142704,
glozow,2020-05-26 17:08:17,"AaaAHhhh, thank you @sipa for the clarification! \n\n> The term ""rolling"" here just means efficient addition as well as deletion from the set being hashed.\n> The ""non-rolling"" mention in @fjahr's document refers to the fact that he hasn't implemented continuous UTXO set hashing with these functions\n\nThis makes a lot more sense; I had thought he meant the hash function itself is rolling/non",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-634155367,634155367,
fjahr,2020-05-26 18:44:49,"> It also seems that ECMH (which is noted as non-rolling) performed better and has a maintainability plus since it's part of Secp256k1.\n\nPlease also note that there is an implementation of ECMH that is an open pull request to Secp256k1 but it is not merged and has been stale for some time. So the work to get it merged is more or less the same and I don't think there is a big difference in main",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-634207235,634207235,
sipa,2020-05-26 21:14:49,"@fjahr I've written a Python implementation of MuHash3072, so it can be more easily tested: https://github.com/sipa/bitcoin/commits/202005_muhash_python (no tests are included, but I've verified it matches the C++ code in a few simple examples).",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-634282984,634282984,
fjahr,2020-05-26 22:22:29,"> @fjahr I've written a Python implementation of MuHash3072, so it can be more easily tested: [sipa/bitcoin@`202005_muhash_python` (commits)](https://github.com/sipa/bitcoin/commits/202005_muhash_python) (no tests are included, but I've verified it matches the C++ code in a few simple examples).\n\nAwesome, I have just pulled it in here and will build further tests on top of it.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-634312013,634312013,
fjahr,2020-05-26 22:28:40,"Rebased and added a6cf0df104728a587283578735e7f11c5f0f2ae4 which allows the user to use the legacy hash with the use of a flag. This will definitely be squashed but I decided to keep it separate for the moment to make discussions easier in the review club tomorrow. I figured I would need to do something like this anyway in order go through a deprecation cycle with `gettxoutsetinfo`, the question i",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-634314204,634314204,
jonatack,2020-05-27 16:01:33,"Also verified that, like your added test in `rpc_blockchain.py`, only `utxo_set_hash` varies between `gettxoutsetinfo` in -regtest with each algo.\n\n```bash \n$ bitcoin-cli -regtest gettxoutsetinfo\n{\n  ""height"": 15599,\n  ""bestblock"": ""6e535bc570f9be1b86d21711b23391e4e8f001682b5c6243883744879cdc4f84"",\n  ""transactions"": 3216,\n  ""txouts"": 3219,\n  ""bogosize"": 234987,\n  ""utxo_set_hash",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-634764233,634764233,
narula,2020-05-27 17:10:46,"nit: ""separate"" is misspelled in the commit title of cda20f3f897ff88337756cb0c0345b41cec9014e\n\nIt might be nice to split this in two PRs: One which adds MuHash, and one which updates `gettxoutsetinfo` to support it. I would definitely at least rebase/squash to put all the MuHash additions first and then layer the functionality changes on top.\n\nEdited to add thought: The next PR could add r",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-634809748,634809748,
DrahtBot,2020-05-27 20:04:35,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #20828 (fuzz: Introduce CallOneOf helper to replace switch-case by MarcoFalke)\n* #19145 (Add hash_type MUHASH for gettxou",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-634910640,634910640,
jonatack,2020-05-29 12:51:57,"It looks like you removed a bunch of code, and the functional tests, in the last push? If yes, review effort is being thrown away, and perhaps the PR description needs to be updated.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-635955599,635955599,
fjahr,2020-05-29 12:53:34,"> It looks like you removed a bunch of code, and the functional tests, in the last push? If yes, review effort is being thrown away, and perhaps the PR description needs to be updated.\n\nYes, I am writing an update at the moment",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-635956325,635956325,
fjahr,2020-05-29 12:53:57,"> nit: ""separate"" is misspelled in the commit title of [cda20f3](https://github.com/bitcoin/bitcoin/commit/cda20f3f897ff88337756cb0c0345b41cec9014e)\n\ndone\n\n",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-635956487,635956487,
fjahr,2020-05-29 13:03:42,"Thanks for all the reviews so far! I have addressed comments and, based on feedback from the PR review club and others, split it up further to make reviews more manageable and keep discussions more focussed. This now only adds the implementation of `Muhash3072` and `TruncatedSHA512` in C++. The next in the series is https://github.com/bitcoin/bitcoin/pull/19105 and will only add the Python impleme",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-635960689,635960689,
fjahr,2020-05-29 13:17:39,"> * This PR essentially makes `gettxoutsetinfo` too slow to be useable in testnet and mainnet (it times out and raises after 15 minutes); for that reason, until the -coinstatsindex in #18000 is merged, the MuHash algorithm should be opt-in for rpc `gettxoutsetinfo` and not the default\n\nWill do so in the follow-up that adds the option to the RPC.\n\n> * What are your plans regarding ECMH?\n",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-635967249,635967249,
jnewbery,2020-06-05 18:29:14,I think it'd be easier to review this code if the PR didn't include the ASM implementation.,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-639690930,639690930,
fjahr,2020-06-05 20:16:26,"> I think it'd be easier to review this code if the PR didn't include the ASM implementation.\n\nYeah, I can split that out easily as well.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-639776914,639776914,
fjahr,2020-06-05 20:24:34,ASM optimizations moved to https://github.com/bitcoin/bitcoin/pull/19181,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-639783978,639783978,
gmaxwell,2020-06-07 07:22:21,Is there a particular reason for sha512?  Although for some sizes it can be faster w/ a totally naive implementation It is a lot slower on hardware with sha-ni (and presumably somewhat slower than a parallel implementation using 8-way avx sha256).,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-640169988,640169988,
sipa,2020-06-07 16:33:11,"@gmaxwell I assume it's SHA512 because of my original code used that. I've pointed out to @fjahr that we should benchmark if SHA256 isn't faster these days (on x86_64, I expect it to be). I hadn't thought of the possibility of parallellizing; that should shift things even further in favor of SHA256.\n\nFWIW, the original reason was that for typical UTXOs, only one SHA512 compression is enough (i",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-640244825,640244825,
fjahr,2020-06-08 15:24:22,"I finally got around to run these benchmarks and it appears that Truncated512 is still significantly faster on my hardware (`Intel(R) Core(TM) i5-6287U CPU @ 3.10GHz`). But I have seen some strange benchmarks before on this machine, so it would be great if others could run them as well. I pushed the code in a new commit, I can remove it again if it is not valuable enough to keep.\n\n`SHA256` res",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-640699423,640699423,
sipa,2020-06-08 18:04:04,"@fjahr It seems the benchmarking framework isn't calling the SHA256AutoDetect() function, which would enable hardware-accelerated versions of SHA256. See #19214 for a fix.\n\nWith that fixed, I get (on my SHA-NI enabled machine):\n\n```\n$ ./src/bench/bench_bitcoin -filter='.*100b' -evals=50\n# Benchmark, evals, iterations, total, min, max, median\nSHA256_100b, 50, 1000000, 4.73236, 9.27549",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-640785035,640785035,
fjahr,2020-06-08 20:41:23,@sipa Thanks for your help! Then I will change the code to use SHA256 which should simplify work for reviewers as well.,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-640875012,640875012,
Sjors,2020-06-09 10:36:44,"Concept ACK. I'm still worried about a lack of test vectors.\n\nIt would be useful to rebase #18000 whenever individual PRs are close to merge-ready. It allows reviewers to sanity check that the end result still produces a blazing fast `gettxoutsetinfo` and that the index builds in reasonable time.\n\nI'm copying the discussion about `TruncatedSHA256Writer` unit tests here (if only to get it i",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-641201795,641201795,
Sjors,2020-06-09 14:51:08,"We should consider switching to the latest `ChaCha20` per RFC 8439, which may or may not produce a different `MuHash3072`. See #19225",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-641348347,641348347,
Sjors,2020-06-09 16:35:46,"From the PR Review club minutes: https://bitcoincore.reviews/19055.html#l-195\n\n> sipa toÂ fjahr: if you're going to cache the hash for every block... that's actually an argument in favor of ECMH, as the minimal ""state"" to keep for ECMH is 33 bytes only, while for MuHash it's 384 bytes\n\nAnd above:\n\n> The primary difference between MuHash and ECMH is caching:\n> \n> * ECMH is more CPU t",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-641420023,641420023,
real-or-random,2020-06-10 12:05:22,"Another data point is the implementation complexity (code lines etc). If we want arithmetic incl. ASM here, this needs to be maintained whereas for ECMH the basic primitives may just be there already there in secp256k1. Not sure if that makes a large difference but it's something to keep in mind.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-641958916,641958916,
fjahr,2020-06-10 13:01:31,> With `-coinstatsindex` we store the UTXO set hash for every height. This makes the RPC blazing fast. With MuHash it uses ~500 MB for the current chain vs 39 MB with ECMH. The latter is so small I can see us turning that on by default one day (assuming ECMH calculation adds negligible overhead to IBD). But 500 MB isn't unacceptable for an advanced user who needs `gettxoutsetinfo` (disclaimer: you,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-641990925,641990925,
Sjors,2020-06-10 13:10:52,"My calculation was based on 768 bytes of cache, but that's off by a factor 2. A finalised MuHash3072 uses 3072 bits. So for 640,000 blocks that's 234 MB.\n\nI suppose you could store just the sha256 hash for historical blocks, only keep 3072 bits for the most recent block, and use that to move forward or roll back. In that case storage is the same as with ECMH. I can't think of a use case for th",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-641996489,641996489,
fjahr,2020-06-11 21:54:33,"Implemented the use of SHA256 and also added some clarification on the ""set"" question in the docs.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-642946245,642946245,
sipa,2020-06-12 18:09:36,"@Sjors If you mean a bigint library for the C++ side, sure - my original email points out that GMP is faster than this code, but I don't want to add a new dependency for this. The Python code uses Python's native bigint support.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-643415794,643415794,
Sjors,2020-06-12 18:18:59,"> a bigint library for the C++ side\n\nThat's what I meant. I agree adding all of GMP is overkill.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-643419477,643419477,
real-or-random,2020-06-12 19:17:23,"There's some discussion about tradeoffs and here's another small point to consider. MuHash3072 introduces cryptographic assumptions that are not used in Bitcoin yet. This is unusual but not a big thing given these are very mild assumptions (i.e., either finite field DL is hard enough *or* Wagner's algorithm is the best method to find collisions here), and most importantly, this is currently just i",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-643442664,643442664,
sipa,2020-06-13 01:57:33,"@gmaxwell Solving the generalized birthday problem is provably as hard as the DL problem in the same group (but it may be much harder as well), I think. So under the assumption that DL is hard in secp256k1, then the generalized birthday problem is hard over it, and that implies collision resistance for the ECMH hash based on it.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-643552222,643552222,
real-or-random,2020-06-13 09:39:06,"Sorry, some theory crypto stuff ahead...\n\n> I find the claim that the EC alternative does not introduce a new cryptographic assumption implausible: You can't break a discrete log by finding a number of random points that you do not know the discrete log of that add to a selected point.\n\nOh, in the (programmable) random oracle model, you can! It's in fact straight forward and it's buried in",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-643598704,643598704,
fjahr,2020-06-14 10:18:02,Addressed @Sjors comments.,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-643746561,643746561,
real-or-random,2020-06-15 11:45:28,"> However this requires modeling the prehashing function as a programmable random oracle. In our case, this function is `ChaCha20-3072-bits(key=SHA256(.))`. This means that we should really have a closer look at this function. I still believe that this is as good as a random oracle if we assume SHA256 is a random oracle and ChaCha20 is an ideal cipher, and this may very well be clear to someone wh",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-644079086,644079086,
fjahr,2020-06-15 14:36:42,Addressed @promag 's review comments.,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-644174444,644174444,
laanwj,2020-06-18 13:06:20,">  That's what I meant. I agree adding all of GMP is overkill.\n\nAlso mind that GMP is not license-compatible with bitcoin (it's LGPL). So, that's another stumbling block besides our desire to limit third-party dependencies.\n\n> As I all these assumptions are fine. However, there's indeed a difference, so\n\nI have a hard time reading how serious your concerns are. So to be clear: in your ",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-646004470,646004470,
real-or-random,2020-06-19 12:47:39,"> I have a hard time reading how serious your concerns are. So to be clear: in your opinion, this is not a blocker for merging this?\n\nSorry if my posts are confusing. I don't have serious concerns at all and no, I don't believe this is a blocker. \n\nLet me try to explain. After I looked at the details, I believe that both MuHash3072 and ECMH (= MuHash on secp256k1) are very solid choices an",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-646616902,646616902,
practicalswift,2020-06-22 13:28:51,"Could rebase on top of #19286 and add fuzzing of the MuHash3072 class to the `src/test/fuzz/crypto.cpp` fuzzing harness in order to demonstrate (some level of) code robustness (more specifically: absence of warnings from ASan, MSan and UBSan when processing malformed/unexpected inputs)? :)",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-647519700,647519700,
fjahr,2020-07-01 21:06:21,"> Could rebase on top of #19286 and add fuzzing of the MuHash3072 class to the `src/test/fuzz/crypto.cpp` fuzzing harness in order to demonstrate (some level of) code robustness (more specifically: absence of warnings from ASan, MSan and UBSan when processing malformed/unexpected inputs)? :)\n\nDone. I am still learning more about fuzzing so looking forward to your feedback. :)",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-652646724,652646724,
Sjors,2020-07-06 11:34:49,"re-ACK 62e842c15eeb7af5d195200d6a605113f16a7e39 modulo ""not interfere with the other fuzzers by changing the data size"". Complete code coverage can wait for a followup (it already covers the basics).",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-654179346,654179346,
fjahr,2020-07-10 14:43:49,Addressed @practicalswift 's feedback and turned the macros into inline functions.,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-656713016,656713016,
practicalswift,2020-07-10 19:03:47,@fjahr Thanks for addressing the fuzzing feedback. The fuzzing changes look good (`src/test/fuzz/crypto.cpp`). (I haven't reviewed the rest yet.),https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-656837402,656837402,
fjahr,2020-07-11 21:23:17,"Replaced the first commit which added `SHA256Writer` with commit 284ca85e3fc4d30f60e7fbb903303b4dc935d82c from #17977 (Taproot) which provides the same functionality in fewer LOC. It uses `CHashWriter` instead of creating a new class, which is nice, and if this gets merged before #17977 there is one less commit to review.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-657132203,657132203,
Sjors,2020-07-24 10:23:44,Let's try to get #18071 in first (for the first commit),https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-663471922,663471922,
laanwj,2020-07-30 12:57:33,"Code review ACK bb3098bbaf1305aa9091ee5e3cd92f2973e04c68\nI have reviewed everything but the MuHash implementation in detail, and looked broadly at the MuHash code but could not follow all the specifics.\n\n> Let's try to get #18071 in first (for the first commit)\n\nMind that there doesn't seem to be agreement on that PR yet.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-666348096,666348096,
laanwj,2020-08-20 14:14:53,"> Let's try to get #18071 in first (for the first commit)\n\nIt's closed now in favor of #19601.\n",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-677692503,677692503,
fjahr,2020-08-27 09:55:35,Rebased since #19601 was merged.,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-681848903,681848903,
laanwj,2020-08-27 14:35:33,"Code review re-ACK 24317aa5a1bd91b90e5971016e842b58f0b4ba62\nThanks for adding a comment to the Inverse function.",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-681989062,681989062,
fjahr,2020-09-11 11:15:38,Rebased,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-691034042,691034042,
fjahr,2020-09-21 22:32:22,"Thanks a lot for the review @ajtowns . I hope I have addressed all of your feedback.\n\n> Would be nice to have more test vectors checking that the c++ and python code end up with the same results. ACK otherwise.\n\nThere are more tests like this coming in the follow-up #19145 . Unless you disagree I would prefer to keep the scope of this PR were it is :)",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-696413868,696413868,
fjahr,2020-10-03 00:02:39,"Pushed fuzz test fixes, thanks @ajtowns !",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-703006924,703006924,
fjahr,2020-10-18 22:45:47,Thanks for the feedback @jnewbery . I implemented most comments while there are still some I need to spend some more time on (including https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507186328 which I can not comment on for some reason).,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-711435198,711435198,
jonatack,2020-10-21 16:01:33,Did a fair amount of testing and review of this on May 27 and plan to re-review after the 0.21 branch-off. ,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-713682094,713682094,
fjahr,2020-11-08 22:44:55,Pushed a fair amount of fixes and refactoring but still working on some of the overflow questions and another fuzz test.,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-723677038,723677038,
jnewbery,2020-11-19 10:41:44,I'm going to move this out of high priority while you're working on the branch. It can go back in once it's ready for review again.,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-730286098,730286098,
fjahr,2020-11-25 21:53:32,This is finally ready for review again. I have added a fuzz test for consistency testing which I am running currently.,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-733962568,733962568,
fjahr,2020-12-16 23:20:23,Rebased and pushed some new comment I seem to have forgotten last time. ,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-747099674,747099674,
fjahr,2020-12-17 23:21:07,"@Sjors Thanks, I updated the Python test, will address your other comments soon. ",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-747766454,747766454,
fjahr,2020-12-22 00:57:37,"Addressed the latest comments.\n\n> Perhaps `Num3072` can have `SERIALIZE_METHODS` (and a test), so that `MuHash3072` can serialise its numerator and denominator without poking into `Num3072` internals.\n\nDone\n",https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-749278131,749278131,
Limpisey168,2020-12-22 10:57:34,So good,https://github.com/bitcoin/bitcoin/pull/19055#issuecomment-749481884,749481884,
jonatack,2020-05-27 12:31:37,ced54242 nit: sort,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r431080029,431080029,src/Makefile.am
jonatack,2020-05-27 13:30:41,"cda20f3 nit: perhaps sort the functions above and this list, e.g. like\n\n```\n$ src/bench/bench_bitcoin -list\n...\nMuHash, 5, 5000, 0, 0, 0, 0\nMuHashAdd, 5, 5000, 0, 0, 0, 0\nMuHashDiv, 5, 100, 0, 0, 0, 0\nMuHashPrecompute, 5, 5000, 0, 0, 0, 0\n\n$ src/bench/bench_bitcoin -filter=MuHash*.*\n# Benchmark, evals, iterations, total, min, max, median\nMuHash, 5, 5000, 0.287426, 7.45603e-",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r431132007,431132007,src/bench/crypto_hash.cpp
jonatack,2020-05-27 13:56:46,"ced54242 and cda20f3f nit: in these four functions above `++i` is preferred over `i++` per doc/developer-notes.md\n\n5d67c47 same for `src/crypto/muhash.h::L71`",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r431151719,431151719,src/bench/crypto_hash.cpp
jonatack,2020-05-27 14:53:12,"a6cf0df1 could add the new `bool GetUTXOStats()` next to the existing one -- to ease review, I moved them together.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r431199564,431199564,src/node/coinstats.cpp
MarcoFalke,2020-05-28 11:53:20,"```suggestion\n                    {""hash_type"", RPCArg::Type::STR, /* default */ ""hash_serialized_2"", ""Which UTXO set hash should be calculated. Options: 'hash_serialized_2' (the legacy algorithm), 'muhash', 'none'.""},\n```\n\nHow much time is spent on hashing with the legacy hash vs muhash vs none? Imagine someone just wants the `total_amount` as fast as possible.\n\nIf hashing is slow in ",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r431778760,431778760,src/rpc/blockchain.cpp
fjahr,2020-05-28 15:54:19,"It's a good question but based on my tests (with commented out hashing code) the performance impact of `hash_serialized2` is only small. Results were volatile but on average `gettxoutsetinfo` without the hash was only a few seconds faster (5s - 20s faster, an improvement of ~10%). I think it's not really worth adding an option for that if we can have the index instead.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r431944665,431944665,src/rpc/blockchain.cpp
fjahr,2020-05-29 11:36:13,"Thinking about it a little bit more, I think it would be good to have the option for later on when we want to remove the code for `hash_serialized_2`. So I will add it as an option.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r432425903,432425903,src/rpc/blockchain.cpp
fjahr,2020-05-29 11:37:08,now out of scope of this PR but will reorg it in the follow-up,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r432426282,432426282,src/node/coinstats.cpp
fjahr,2020-05-29 11:37:15,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r432426338,432426338,src/bench/crypto_hash.cpp
fjahr,2020-05-29 11:37:23,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r432426405,432426405,src/bench/crypto_hash.cpp
fjahr,2020-05-29 11:37:31,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r432426468,432426468,src/Makefile.am
fjahr,2020-06-05 20:14:59,This is now implemented in #19145.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r436143516,436143516,src/rpc/blockchain.cpp
Sjors,2020-06-09 11:07:41,"Maybe link to the paper and mailinglist discussion here:\n* https://cseweb.ucsd.edu/~mihir/papers/inchash.pdf (explains MuHASH in general terms)\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014337.html (picks SHA512 and ChaCha20)",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r437326492,437326492,src/crypto/muhash.h
Sjors,2020-06-09 15:22:14,"Let's add some info about the choice of SHA256 + ChaCha20 here. It essentially compresses the item (e.g. a serialised UTXO) into 3072 bits. Because ChaCha20 doesn't compress - it's designed for encryption - we feed it a SHA256() hash; it then decompresses that 256 bits into 3072.\n\nWhy 3072 bits? Because it's safe enough, according to @sipa's mailinglist post:\n```\nThankfully, [6] also shows",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r437515881,437515881,src/crypto/muhash.h
real-or-random,2020-06-10 10:35:36,">  Because ChaCha20 doesn't compress - it's designed for encryption - we feed it a SHA256() hash; it then decompresses that 256 bits into 3072.\n\nI think that argument is a little too ad-hoc for serious crypto. The MuHash paper assumes that elements are first hashed with a hash function that they model as a random oracle (RO). Now while SHA256 with fixed inputs itself is a good choice for somet",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r438026185,438026185,src/crypto/muhash.h
Sjors,2020-06-10 13:00:47,"> I think that argument is a little too ad-hoc for serious crypto.\n\nCompletely agree. I'm trying to tease out what we know. For the purpose of an index it doesn't matter too much. We can use MuHash to experiment with this concept, and abandon it for something better. By the time anyone proposes to use this for consensus, we'll need a much stronger proof.\n\nThat said, there should be strongl",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r438102500,438102500,src/crypto/muhash.h
Sjors,2020-06-12 16:49:17,nit fe9ea729fc67e012de773975018a0f749c03790f: might as well move all bench code to 5675d28f22b3e3745226f40aac023c0d689b5acd ,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r439532565,439532565,src/bench/crypto_hash.cpp
Sjors,2020-06-12 16:59:28,`unsigned char out[32];` is added in 106f9148848ffa64b433f1bc2dd6980930a4cb02 and dropped in fe9ea729fc67e012de773975018a0f749c03790f,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r439537666,439537666,src/hash.h
fjahr,2020-06-14 10:17:29,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r439813927,439813927,src/bench/crypto_hash.cpp
fjahr,2020-06-14 10:17:33,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r439813934,439813934,src/hash.h
promag,2020-06-14 23:37:26,"d111135a3c928d1915f48cb4d46ca89a3d179686\n\nnit, space after `for`.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r439879174,439879174,src/crypto/muhash.h
promag,2020-06-14 23:39:36,"d111135a3c928d1915f48cb4d46ca89a3d179686\n\nnit, newline after, usually project headers are split from others.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r439879324,439879324,src/crypto/muhash.h
promag,2020-06-14 23:41:04,"4b493677ab2c1d90cb8b11659660d18c3f61171f\n\nShould these assertions be conditional to `#ifdef DEBUG`? Same in `Multiply`.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r439879455,439879455,src/crypto/muhash.cpp
promag,2020-06-14 23:41:26,"4b493677ab2c1d90cb8b11659660d18c3f61171f\n\nnit, add `// namespace`.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r439879482,439879482,src/crypto/muhash.cpp
promag,2020-06-14 23:55:13,"18c4d69f8d771aa596a321cf1d6c8e6e106d42a9\n\nnit, should fix format.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r439880752,439880752,src/hash.h
fjahr,2020-06-15 14:35:28,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r440221681,440221681,src/hash.h
fjahr,2020-06-15 14:35:34,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r440221759,440221759,src/crypto/muhash.cpp
fjahr,2020-06-15 14:35:39,Makes sense to me. Added.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r440221831,440221831,src/crypto/muhash.cpp
fjahr,2020-06-15 14:35:44,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r440221890,440221890,src/crypto/muhash.h
fjahr,2020-06-15 14:35:53,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r440221999,440221999,src/crypto/muhash.h
laanwj,2020-06-18 13:07:41,Why are these implemented as macros instead of (inline) functions?,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r442211563,442211563,src/crypto/muhash.cpp
fjahr,2020-07-01 21:25:06,"I am not aware of a reason why inline functions couldn't be used here. From my side, the only reason is that this is @sipa 's original code and I did not feel so strongly about it that it justified a bigger change. Of course, I will do it if that's preferred by reviewers.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r448624203,448624203,src/crypto/muhash.cpp
sipa,2020-07-01 21:39:01,"It may have been that I copied this from code that was originally written for C.\n\nFeel free to change it; inline functions would be far more C++ish.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r448630059,448630059,src/crypto/muhash.cpp
practicalswift,2020-07-01 21:40:17,Nit: `MuHash3072 muhash;` is enough :),https://github.com/bitcoin/bitcoin/pull/19055#discussion_r448630571,448630571,src/test/fuzz/crypto.cpp
practicalswift,2020-07-01 21:46:14,"To not interfere with the other fuzzers by changing the data size, what about either creating a new `case 3` specifically for this MuHash3072 code (the resize and the lines immediately below), or alternatively do something along the lines of `std::vector<uint8_t> muhash_data = data;` + `muhash_data.resize(32);`?",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r448633047,448633047,src/test/fuzz/crypto.cpp
practicalswift,2020-07-01 21:50:38,"Make sure you also exercise the other constructor `MuHash3072::MuHash3072(const unsigned char* key32)`. Perhaps `ConsumeBool()` to choose which constructor to use?\n\nGenerally a good thing to do when testing a fuzzer is to add `assert(false);` to all code paths you want to reach and then fuzz/tweak/repeat until you've reached them all.\n\nIn this case we want to make sure that relevant code p",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r448634840,448634840,src/test/fuzz/crypto.cpp
jnewbery,2020-07-01 22:00:07,Brevity is the soul of wit,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r448638490,448638490,src/test/fuzz/crypto.cpp
fjahr,2020-07-10 14:40:33,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r452886409,452886409,src/test/fuzz/crypto.cpp
fjahr,2020-07-10 14:41:01,"done, opted for your second suggestion.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r452886730,452886730,src/test/fuzz/crypto.cpp
fjahr,2020-07-10 14:43:00,That constructor is used for the MuHash objects that get added or removed. I checked all the public functions as you suggested and they seem to all be covered.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r452887936,452887936,src/test/fuzz/crypto.cpp
Sjors,2020-07-16 13:06:48,"Shouldn't `GetCheapHash` be calling `GetSHA256`? I.e. ""Cheap"" refers to a single rather than a double hash. cc @JeremyRubin @sipa ",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r455770853,455770853,src/hash.h
JeremyRubin,2020-07-24 16:49:32,"No because it's a behavior change :/\n\nIf someone wants to make sure that we don't rely on cheaphashes being consistent across boots then yes.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r460171013,460171013,src/hash.h
sipa,2020-07-24 16:52:08,"Addrman's bucketing relies on it.\n\nWith a new addrman version we could change it to siphash instead, which would let us get rid of GetCheapHash entirely.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r460172516,460172516,src/hash.h
laanwj,2020-07-30 13:21:41,"It would be nice to document here in a comment why this particular cascade is used, and how it works. It is not obvious to me.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r462991147,462991147,src/crypto/muhash.cpp
fjahr,2020-08-23 15:36:02,"I have added a reference to a paper that explains this algorithm. Unfortunately, I think there is no publicly accessible version of that paper that we can link to here. The paid version is here: https://link.springer.com/chapter/10.1007/978-3-540-69485-4_10.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r475233273,475233273,src/crypto/muhash.cpp
ajtowns,2020-09-16 02:05:46,"I think this should be `obj.data.LIMBS` and `obj.data.limbs[i]` ? Can add:\n\n```c++\n#include <streams.h>\n...\n    CDataStream ss(SER_DISK, PROTOCOL_VERSION);\n    ss << acc;\n```\n\nto exercise the code.\n\nIf this is being serialized by directly dumping the limbs, is there a problem if the code that serializes it uses `uint64_t` limbs and the code that deserializes uses `uint32_t` l",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r489117810,489117810,src/crypto/muhash.h
ajtowns,2020-09-16 02:55:58,Might be better to accept a `Span` rather than having an implicit length? Also for `Finalize` perhaps -- sha3.cpp does it that way.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r489131218,489131218,src/crypto/muhash.h
ajtowns,2020-09-16 03:05:10,"Might be worth clarifying that muhash does not support checking if an element is a member of the set, and therefore it's not possible to (efficiently) enforce that you don't add members that are already in the set, or remove members that aren't in the set?\n\nMight also be worth being more explicit that the ""represent the running value as a fraction"" optimisation is a TODO.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r489133613,489133613,src/crypto/muhash.h
ajtowns,2020-09-16 03:12:53,"The headers suggest that removing things that aren't in the set is a bad idea (""not clear if the security assumptions still hold"", ""should for now only be used to represent a set of elements"") so seems a bit odd to be doing it in the tests. Could convert it to `z *= x; z *= y; y *= x; z /= y;` to only add things that aren't present/remove things that are present.\n\nI think the comment in the he",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r489135525,489135525,src/test/crypto_tests.cpp
ajtowns,2020-09-16 04:56:58,Might as well move the `d->limbs[0]` case prior to the for loop.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r489161487,489161487,src/crypto/muhash.cpp
ajtowns,2020-09-16 05:12:58,"I think the for loop should be `i = 1; i < LIMBS; ++i` not `LIMBS-1`?\n\nMight be clever to have `data` be `protected` rather than `private` so it can be initialised directly to edge cases via a subclass in the unit tests, without having to find a chacha-primage for them.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r489167116,489167116,src/crypto/muhash.cpp
ajtowns,2020-09-16 05:28:26,"This is only ever called with `out == a`, so could take a single argument. Similarly for Multiply which is also always in-place.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r489171646,489171646,src/crypto/muhash.cpp
ajtowns,2020-09-16 06:47:08,"Dropping all the `Num3072::` prefixes might make the code a little less noisy:\n\n```c++\nusing limb_type = Num3072::limb_type;\nusing double_limb_type = Num3072::double_limb_type;\nconstexpr int LIMB_SIZE = Num3072::LIMB_SIZE;\nconstexpr int LIMBS = Num3072::LIMBS;\n```\n\n(also, wouldn't `limb_t` be more normal than `limb_type`?)\n\nProbably overkill, but maybe consider checking the `",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r489200958,489200958,src/crypto/muhash.cpp
fjahr,2020-09-21 22:17:18,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492377373,492377373,src/crypto/muhash.cpp
fjahr,2020-09-21 22:17:25,I think all these suggestions are sensible. Added.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492377415,492377415,src/crypto/muhash.cpp
fjahr,2020-09-21 22:17:47,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492377548,492377548,src/crypto/muhash.cpp
fjahr,2020-09-21 22:18:00,"Yeah, I think this makes sense. From what I have read I think there was just no research done on the security of this. I think it makes sense to be defensive but I amended the comment that this would just not the intended use. I also updated the test to follow this.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492377632,492377632,src/test/crypto_tests.cpp
fjahr,2020-09-21 22:18:43,"Updated that part a bit, I hope this is more clear.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492377900,492377900,src/crypto/muhash.h
fjahr,2020-09-21 22:18:49,Makes sense. Done.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492377925,492377925,src/crypto/muhash.h
fjahr,2020-09-21 22:21:20,"Thanks, this was a bug. I also added that test in an additional commit.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492378952,492378952,src/crypto/muhash.h
fjahr,2020-09-21 22:24:09,"Yeah, that makes sense. I also took your suggestion and added a basic test that executes the `IsOverflow` function which wasn't covered so far.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492379981,492379981,src/crypto/muhash.cpp
ajtowns,2020-09-22 15:30:36,"Confirmed that this is calculating `out = a ** (2**3072 - MAX_PRIME_DIFF - 2)` by noting that all the operations are multiplicative and thus you can take the log of everything in base `a`, giving:\n\n```python\n>>> p = [2**(2**i)-1 for i in range(12)]\n>>> def double_n_add(x, n, pn):\n...     for j in range(n): x *= 2\n...     return x + p[pn]\n... \n>>> x = p[11]\n>>> x = double_n_add(x,",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492832419,492832419,src/crypto/muhash.cpp
ajtowns,2020-09-22 16:18:28,Missing `}` for case 9.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492867088,492867088,src/test/fuzz/crypto.cpp
ajtowns,2020-09-22 16:18:40,`Finalize(data)`,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492867231,492867231,src/test/fuzz/crypto.cpp
ajtowns,2020-09-22 16:18:57,`MuHash3072(muhash_data)`,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r492867426,492867426,src/test/fuzz/crypto.cpp
fjahr,2020-10-03 00:02:48,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r499093557,499093557,src/test/fuzz/crypto.cpp
fjahr,2020-10-03 00:02:57,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r499093569,499093569,src/test/fuzz/crypto.cpp
fjahr,2020-10-03 00:03:04,done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r499093583,499093583,src/test/fuzz/crypto.cpp
jnewbery,2020-10-18 14:31:50,It seems a shame to make `Num3072` part of the public interface just so it can be used in a single test in crypt_tests.cpp. Is there a way the overflow test can be written without using the `Num3072` class?,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507170069,507170069,src/crypto/muhash.h
jnewbery,2020-10-18 14:32:27,This doesn't need to be in the public interface and can be in the .cpp file's unnamed namespace.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507170142,507170142,src/crypto/muhash.h
jnewbery,2020-10-18 14:32:59,Any reason not to use the project's style guide and name member variables with an `m_` prefix?,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507170212,507170212,src/crypto/muhash.h
jnewbery,2020-10-18 14:33:32,"Again, it'd be nice if these weren't exposed in the header file and were moved to the cpp file's unnamed namespace.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507170280,507170280,src/crypto/muhash.h
jnewbery,2020-10-18 14:56:08,Is this platform independent (ie between HAVE___INT128 and !HAVE___INT128 platforms)? I guess so because the unit tests are asserting exact serializations.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507173075,507173075,src/crypto/muhash.h
jnewbery,2020-10-18 15:00:01,"Has the performance benefit of using `__int128` been measured? My instinct would be to remove the platform-dependent code, including all the typedefs and static_asserts.	There are benefits to having just a single implementation (simpler, smaller code), and the performance of the mushash implementation isn't critical, since it'll only be used in indexing and the rpc interface.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507173583,507173583,src/crypto/muhash.h
jnewbery,2020-10-18 15:47:19,"Consider using a range based loop:\n\n```suggestion\n        for (auto& limb : obj.data.limbs) {\n            READWRITE(limb);\n        }\n```",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507178737,507178737,src/crypto/muhash.h
jnewbery,2020-10-18 15:52:48,"All of these functions (`IsOverflow()`, `FullReduce()`, `Multiply()`, `Square()`, `Inverse()`) take pointers, but they're always called with non-null ptrs and there's no null checking in the function body. Consider changing the signatures to take references to better express that they must be called with an actual object.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507179354,507179354,src/crypto/muhash.cpp
jnewbery,2020-10-18 15:56:13,s/to do so../to do so./ (remove double .),https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507179765,507179765,src/crypto/muhash.h
jnewbery,2020-10-18 16:27:55,"Why not implicit `this`?\n\n```suggestion\n    Multiply(&data, &x.data);\n```\n\nThis would be even clearer if Multiply took references and `data` was renamed `m_data`:\n\n`Multiply(m_data, x.m_data);`\n\nSame below in the `/=()` operator",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507183199,507183199,src/crypto/muhash.cpp
jnewbery,2020-10-18 16:38:58,It seems odd that the argument to the multiplication operator is called `add` and the argument to the division operator is called `sub`. Stick to either multiplicative or additive terminology!,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507184333,507184333,src/crypto/muhash.h
jnewbery,2020-10-18 16:56:53,"This is really helpful, and makes it easier to understand what the algorithm is doing.\n\nI wonder if converting the c++ code to use a `DOUBLE_N_ADD()` macro and adding a comment on how to audit the numbers would make it easier to follow the code.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507186328,507186328,src/crypto/muhash.cpp
jnewbery,2020-10-18 16:57:30,"Is there anywhere to get hold of this paper, or a write-up of this technique?",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507186374,507186374,src/crypto/muhash.cpp
jnewbery,2020-10-18 18:14:23,"What are these indentations for? I think it'll compile to the same thing without them, and this just makes the code harder to read. There are similar blocks in `muldbladd3()` and `Multiply()`.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507194862,507194862,src/crypto/muhash.cpp
fjahr,2020-10-18 22:41:09,I have to think a little more about to how solve that best...,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507231955,507231955,src/crypto/muhash.h
fjahr,2020-10-18 22:41:15,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507231982,507231982,src/crypto/muhash.h
fjahr,2020-10-18 22:41:21,"Nope, done",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232033,507232033,src/crypto/muhash.h
fjahr,2020-10-18 22:41:25,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232065,507232065,src/crypto/muhash.h
fjahr,2020-10-18 22:42:05,"I believe so, I definitely forced either option on my system at some point.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232365,507232365,src/crypto/muhash.h
fjahr,2020-10-18 22:42:10,"I don't remember benchmarking this, will do so",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232390,507232390,src/crypto/muhash.h
fjahr,2020-10-18 22:42:14,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232419,507232419,src/crypto/muhash.h
fjahr,2020-10-18 22:42:20,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232453,507232453,src/crypto/muhash.cpp
fjahr,2020-10-18 22:42:24,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232479,507232479,src/crypto/muhash.h
fjahr,2020-10-18 22:42:32,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232528,507232528,src/crypto/muhash.cpp
fjahr,2020-10-18 22:42:38,I prefer the additive terminology personally and I thought they were both using it: `add` and `sub`tract? What would you prefer? `rem` for remove?,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232586,507232586,src/crypto/muhash.h
fjahr,2020-10-18 22:42:56,I did spend quite some time looking for something but the paper is only available behind a paywall and a friend told me there are other sources but that we might not want to link to those. I didn't find any summaries or so on the topic so if we want more details I would need to write something up myself I think.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507232707,507232707,src/crypto/muhash.cpp
fjahr,2020-10-18 22:43:30,Removed them,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507233000,507233000,src/crypto/muhash.cpp
sipa,2020-10-18 22:56:14,I expect a 4x speed difference approximately. Being able to use 64-bit multiplication hardware makes a huge difference.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507238291,507238291,src/crypto/muhash.h
ajtowns,2020-10-19 02:01:10,"The C++ code would be `square_n_mul`. Just having an inline function to calculate `x**(2**n)` -- ie the ""square n times"" part would probably already make it easier to follow.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507347412,507347412,src/crypto/muhash.cpp
ajtowns,2020-10-19 02:07:03,"This is just an explanation of how the constants were chosen in the first place. I think it's only interesting in the same way references in an academic paper help trace the lineage of an idea rather than actually useful for reviewing the code as it stands -- ie, handy if you want to reinvent it, eg if 3072 bits aren't enough and you need to pick a new prime and hence new constants for efficient i",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507352789,507352789,src/crypto/muhash.cpp
jnewbery,2020-10-19 07:06:53,I'd prefer `mul` and `div` for the multiplier and divisor operators. Alternatively change the operators to `+=` and `-=`.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507517654,507517654,src/crypto/muhash.h
jnewbery,2020-10-19 09:13:08,No need to mark these as static. Being in the unnamed namespace already means that they don't have external linkage.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507593284,507593284,src/crypto/muhash.cpp
jnewbery,2020-10-19 09:13:49,No need to declare these variables up here. Just declare them where you need them. Same in other functions below.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507593683,507593683,src/crypto/muhash.cpp
jnewbery,2020-10-19 09:17:46,Agree. I don't think there's anything more needed here.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507596124,507596124,src/crypto/muhash.cpp
jnewbery,2020-10-19 09:18:27,"Implicit `this`:\n\n```suggestion\n    Multiply(m_data, tmp);\n```",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507596535,507596535,src/crypto/muhash.cpp
jnewbery,2020-10-19 09:21:26,"Why is this temporary needed? Can we just construct `out` here?\n\nChanging the function signature to `Num3072 Inverse(const Num3072& in)` would use RVO and avoid copying `x` to `out`.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507598399,507598399,src/crypto/muhash.cpp
jnewbery,2020-10-19 09:27:34,"We don't usually compile out asserts in our code (in fact, I can't see any other examples in the codebase). I suggest removing this `Ifdef`.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507602363,507602363,src/crypto/muhash.cpp
jnewbery,2020-10-19 09:40:00,`add2()` is always followed by `extract2()`. Does it make sense to refactor these two functions into a single function?,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507610270,507610270,src/crypto/muhash.cpp
jnewbery,2020-10-19 15:10:50,"Did you consider making the argument to the constructor and `Finalize()` functions references to array rather than spans? Doing so reduces flexibility (eg you wouldn't be able to Finalize into a vector, although I can't imagine you'd ever want to do that) but increases safety (you can enforce the inputs at compile time rather than asserting at runtime).",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r507832149,507832149,src/crypto/muhash.h
fjahr,2020-10-19 21:55:16,"Hm, making an `add_and_extract2()` to use it in 3 places doesn't feel like an improvement to me TBH.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508085588,508085588,src/crypto/muhash.cpp
fjahr,2020-10-19 21:55:19,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508085622,508085622,src/crypto/muhash.cpp
fjahr,2020-10-19 21:55:27,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508085686,508085686,src/crypto/muhash.cpp
fjahr,2020-10-19 21:55:35,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508085738,508085738,src/crypto/muhash.cpp
fjahr,2020-10-19 21:55:40,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508085805,508085805,src/crypto/muhash.cpp
fjahr,2020-10-19 21:55:46,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508085835,508085835,src/crypto/muhash.cpp
fjahr,2020-10-19 21:55:57,"Hm, yeah, with the operators in mind that naming makes more sense. Changed to `mul` and `div`.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508085917,508085917,src/crypto/muhash.h
fjahr,2020-10-19 22:15:12,"Benchmarks on my machine with and without `__int128` (values hardcoded instead) show a significant speedup:\n\nWith `__int128`:\n```\n|               ns/op |                op/s |    err% |     total | benchmark\n|--------------------:|--------------------:|--------:|----------:|:----------\n|            3,313.23 |          301,820.21 |    0.1% |      0.00 | `MuHash`\n|            2,544.00 ",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508093977,508093977,src/crypto/muhash.h
jnewbery,2020-10-20 07:05:48,"> Same in other functions below.\n\nLooks like you missed these.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508256703,508256703,src/crypto/muhash.cpp
jnewbery,2020-10-20 07:19:17,"No need for a blank line here. These are all standard library includes and can be grouped together (as well as using the C++ header names):\n\n```suggestion\n#include <cassert>\n#include <cstdio>\n#include <limits>\n```",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508264086,508264086,src/crypto/muhash.cpp
jnewbery,2020-10-20 07:19:53,'next' from what? Is this just the largest 3072 bit safe prime number?,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508264443,508264443,src/crypto/muhash.cpp
jnewbery,2020-10-20 07:39:32,"`limb_t& a` can be const, to indicate that it's an in-param (as is done for the in-params in the other helper functions)",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508275969,508275969,src/crypto/muhash.cpp
jnewbery,2020-10-20 07:41:16,"I think this function can overflow. If c1 is limb_t::max, and c0 + a overflows, then c1 + 1 overflows and the top bit is lost.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508277075,508277075,src/crypto/muhash.cpp
jnewbery,2020-10-20 07:41:52,My suggestion was to merge `add2()` and `extract2()` since they're always called as a pair.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508277430,508277430,src/crypto/muhash.cpp
jnewbery,2020-10-20 07:53:23,`t` is a local variable so is dropped immediately after this bitshift.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508284709,508284709,src/crypto/muhash.cpp
fjahr,2020-10-20 20:26:41,Removed,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508817012,508817012,src/crypto/muhash.cpp
fjahr,2020-10-20 20:26:55,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508817120,508817120,src/crypto/muhash.cpp
fjahr,2020-10-20 20:27:15,"Weird, I don't know how that made it in there, removed `next`",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508817390,508817390,src/crypto/muhash.cpp
fjahr,2020-10-20 20:27:23,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r508817491,508817491,src/crypto/muhash.cpp
jnewbery,2020-10-21 09:29:38,"This function name is slightly confusing. This isn't returning whether the number has overflown the range that can be expressed in a Num3072. It's returning whether the number d is greater than the group order g and can therefore be reduced to a congruent value < g. I'd suggest renaming the function to `IsReduceable()` or `CanReduce()`, and commenting what the function is doing.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509130310,509130310,src/crypto/muhash.cpp
jnewbery,2020-10-21 09:47:33,"This could also use a comment. We call this function in two places:\n\n1. After `IsOverflow` where `x â [g, MAX_NUM3072)`. In this case`FullReduce(x)` adds `MAX_PRIME_DIFF` to `x` and overflows Num3072, so `FullReduce(x) = x + MAX_PRIME_DIFF - MAX_NUM3072 = x - g`, which is congruent to x and is in `[0, g)`\n\n2. After `if (c0)` i.e. where x has overflown and `x = MAX_NUM3072 + d`. In this cas",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509142040,509142040,src/crypto/muhash.cpp
jnewbery,2020-10-21 09:51:11,"slightly confusing to have `c0` and `c1` declared at the top of the function, and `c2` declared both in the for block above here and again here. Perhaps move this declaration to the top too and reuse the variable. `c2` is always zero after `extract3()`, but you could assert that here to be clear.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509144274,509144274,src/crypto/muhash.cpp
jnewbery,2020-10-21 09:52:49,Same as above. Any reason not to declare this `c2` at the top and reuse the variable?,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509145379,509145379,src/crypto/muhash.cpp
jnewbery,2020-10-21 09:59:37,That's almost exactly a 4x speedup for add and >5x speedup for div. Seems worthwhile!,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509149688,509149688,src/crypto/muhash.h
jnewbery,2020-10-21 10:05:12,Change this to `MuHashMul()`?,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509153295,509153295,src/bench/crypto_hash.cpp
jnewbery,2020-10-21 10:05:37,`rng` is unused. Remove it.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509153543,509153543,src/bench/crypto_hash.cpp
jnewbery,2020-10-21 10:08:51,I don't think this is needed. There's nothing wrong with dividing by elements that aren't in the muhash.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509155449,509155449,src/bench/crypto_hash.cpp
jnewbery,2020-10-21 10:19:32,"The temporary array and vector variables are unnecessary here. The MuHash constructor takes a span, so we can just call it directly with the rvalue vector from randbytes().\n\n```suggestion\n    MuHash3072 acc;\n    FastRandomContext rng(true);\n    MuHash3072 muhash{rng.randbytes(32)};\n\n```\n\nSame in the other functions below.\n",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509161865,509161865,src/bench/crypto_hash.cpp
jnewbery,2020-10-21 10:23:00,"Again, this isn't actually overflowing the data type in MuHash. It's simply reducing a number greater than the group order into its least residue. Consider renaming this function/class.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509163922,509163922,src/test/crypto_tests.cpp
fjahr,2020-10-21 15:42:24,"Initally yes, should be done now.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509396869,509396869,src/crypto/muhash.cpp
real-or-random,2020-10-21 17:21:47,"Hm, we use the same ""overflow"" terminology in secp256k1. The idea is that Num3072 represents a number in the range 0 to group order, so when it's larger it has overflown this range. (Idk, this may be a matter of taste...)\n\n""IsReduceable()"" sounds also confusing to me. You can reduce a reduced number, it just won't change.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509469267,509469267,src/crypto/muhash.cpp
jnewbery,2020-10-21 19:17:16,"s/order of the group/modulus/\n\n(the order of the group is 2^3072 - 1103717 - 1, since 0 isn't in the multiplicative group)",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509602615,509602615,src/crypto/muhash.cpp
jnewbery,2020-10-22 07:37:01,"Ah, I didn't realise that 'overflow' was the terminology used for ""d is larger than the modulus"". I suppose `IsNotLeastResidue()` would be most accurate, but as long as the terminology overflow is used consistently, I think just a comment is enough here.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509942735,509942735,src/crypto/muhash.cpp
jnewbery,2020-10-22 14:58:12,"This does seem like a strange interface: both high-level (the user doesn't need to know/worry about the chacha20 operation) and low-level (the user needs to apply a truncated SHA-512 to all inputs, track numerator and denominator when doing a bulk update, and SHA256 the finalized 3072-bit output). I think it makes sense to refactor this so that there are two classes:\n\n- a Num3072 class that is",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510232044,510232044,src/crypto/muhash.h
elichai,2020-10-22 15:42:24,"FWIW the ""real span"" can do `std::span<const uint8_t, 32>` to force the size possibly at compile time.\n(maybe we should look into extending our span impl to support that)",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510265495,510265495,src/crypto/muhash.h
elichai,2020-10-22 15:44:58,@sipa When safegcd? ;),https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510267390,510267390,src/crypto/muhash.cpp
elichai,2020-10-22 15:59:12,"The paper if anyone wants: https://sci-hub.do/10.1007/978-3-540-69485-4_10\nas for the technique AFAIU(didn't review the actual code here) it's simply fermat little theorem (a^p-2=1/a) together with a simple square-and-multiply algorithm (in elliptic curves it's called double-and-add) \nGood references:\nhttps://en.wikipedia.org/wiki/Exponentiation_by_squaring\nhttps://briansmith.org/ecc-inver",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510278063,510278063,src/crypto/muhash.cpp
sipa,2020-10-22 16:04:38,@elichai That's the easy part. It's specifically using a technique here to construct an efficient exponentiation ladder for an exponent with many consecutive 1s.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510282032,510282032,src/crypto/muhash.cpp
elichai,2020-10-22 16:07:23,@sipa you're right. I ignored how you came up with that specific ladder because I didn't actually review the ladder itself (ops),https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510283904,510283904,src/crypto/muhash.cpp
jnewbery,2020-10-22 17:49:04,Interesting. I wasn't aware of that. Does that mean it can't be initialized with a vector (since it's not possible to know the size at compile time)?,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510348467,510348467,src/crypto/muhash.h
sipa,2020-10-22 23:07:53,"It can, but only explicitly. So you'd be able to write `MuHash3072(std::span<const unsigned char, 32>(vec))` but not `MuHash3072(vec)`.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510506704,510506704,src/crypto/muhash.h
jnewbery,2020-10-23 07:38:19,"I think I prefer that interface. It forces the client code to explicitly set the span size. Of course they can still create a span from a too-small vector, but that's a client bug rather than an unexpected assert in the library.\n\nIn any case, my recommendation would be to make the MuHash class take any stream input and do the truncated SHA512 inside the class (https://github.com/bitcoin/bitcoi",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510692813,510692813,src/crypto/muhash.h
ajtowns,2020-10-28 07:49:32,"""multiply"" and ""divide"" (or mul/div) for the maths, and ""insert"" and ""remove"" for higher level (multi)set-like operations might make sense. ""Add"" definitely seems confusing.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r513237387,513237387,src/bench/crypto_hash.cpp
jnewbery,2020-10-28 08:42:51,"My preferred naming for the operations is here: https://github.com/bitcoin/bitcoin/pull/19055#discussion_r510232044 (mul/div for Num3072, add/sub for MuHash), but I mostly just want it to be consistent.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r513266246,513266246,src/bench/crypto_hash.cpp
fjahr,2020-11-08 22:25:02,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519485719,519485719,src/crypto/muhash.cpp
fjahr,2020-11-08 22:27:06,Since the overflow naming is consistent with secp256k1 I kept it but extended the comment for clarification.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519485947,519485947,src/test/crypto_tests.cpp
fjahr,2020-11-08 22:27:41,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519486012,519486012,src/bench/crypto_hash.cpp
fjahr,2020-11-08 22:30:49,"This is true but it's not how we intend to use it. I have left this as is. Otherwise, it might be inconsistent with the docs and might give the wrong impression on the usage. ",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519486351,519486351,src/bench/crypto_hash.cpp
fjahr,2020-11-08 22:30:53,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519486360,519486360,src/bench/crypto_hash.cpp
fjahr,2020-11-08 22:31:20,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519486413,519486413,src/bench/crypto_hash.cpp
fjahr,2020-11-08 22:31:32,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519486432,519486432,src/crypto/muhash.cpp
fjahr,2020-11-08 22:31:39,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519486465,519486465,src/crypto/muhash.cpp
fjahr,2020-11-08 22:32:12,Added a comment for clarification.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519486529,519486529,src/crypto/muhash.cpp
fjahr,2020-11-08 22:32:54,Done,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519486578,519486578,src/crypto/muhash.cpp
fjahr,2020-11-08 22:43:41,I have refactored the code to have clearer boundaries between the two classes. Let me know if this matches your expectation.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r519487839,519487839,src/crypto/muhash.h
fjahr,2020-11-25 21:52:10,"If I got this right, 2. basically means we can have `if (c0)` or `if (IsOverflow())` or both, and in the case of both there is a problem. If I understood that correctly I have addressed this in `Square()` and `Multiply()` with an additional comment.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r530660278,530660278,src/crypto/muhash.cpp
fjahr,2020-11-25 21:52:18,I think that is correct. At least I could not find evidence for the opposite. The way it is used it can only happen in `Multiply()` and `Square()` and only on the first limb. I think I have fixed this with a temporary internal c2 variable that catches this overflow if it happens.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r530660331,530660331,src/crypto/muhash.cpp
fjahr,2020-11-25 21:52:44,Finally had the (seemingly obvious) idea to solve this with a serialized MuHash3072 object.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r530660479,530660479,src/crypto/muhash.h
Sjors,2020-12-17 13:27:43,"515ee0d0ca91bfdf6a9cd844824e747291efabe9: build system stuff could warrant a separate commit. It gets picked up on my macOS machine, so that's good.\n\nI you end up splitting the commit, you might as well also introduce `MuHash3072` in its own commit.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r545088857,545088857,configure.ac
Sjors,2020-12-17 14:21:51,"I suggest either making `a` `const` (like `Multiply`) or, if it hurts performance, `Divide` private with `MuHash3072` as its friend.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r545126648,545126648,src/crypto/muhash.h
Sjors,2020-12-17 14:45:51,"#20315 dropped our big endian Travis instance, but that shouldn't be a problem. Took me a while to wrap my head around... Each limb is serialised as little endian, because `serialize.h` converts `uint32_t` and `uint64_t` to little endian, using  `htole32` / `htole64`. We also treat the collection of limbs as little endian, with the first limb having the least significant digit. This means we can s",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r545144564,545144564,src/crypto/muhash.h
sipa,2020-12-18 21:49:30,"If the ""MuHash3072"" type is an encapsulation of a set-hash state, then perhaps it's better to give this name ""Add"" or ""Union"" (with a comment explaining the implications of it having multiset semantics)?\n\nAlso, using this with a pattern of ""accumulator *= MuHash3072{data}"" will involve two multiplications, but the one with the denominator is always 1. Perhaps it's better to have ""Insert"" and """,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r546107086,546107086,src/crypto/muhash.cpp
elichai,2020-12-19 08:12:35,"Yep, I'm actually implementing a similar accumulator in Go and I'm using Add/Remove that both do a single multiplication and Combine that combines 2 ""accumulators"" and does 2 multiplications.\nalso serializing/deserializing can be quite helpful (probably will work similar to finalize, by dividing, normalizing and outputting the numerator)\n\nFWIW I also tested replacing hash+Chacha20 with a XOF",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r546209372,546209372,src/crypto/muhash.cpp
fjahr,2020-12-22 00:55:04,"@jnewbery and @ajtowns didn't like ""Add"" (https://github.com/bitcoin/bitcoin/pull/19055#discussion_r509153295) and personally I am not sure about ""Union"" yet so I have kept the namings of *= and /= for now but I have added `Insert` and `Remove` to insert and remove single elements with a single multiplication as suggested.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r547006838,547006838,src/crypto/muhash.cpp
fjahr,2020-12-22 00:55:58,I do a reduction on `a` if it's needed so when it's `const` I would need an intermediary variable. But at least this should not happen too often so I implemented this although it complicates the code a little bit so I am still undecided if it's an improvement.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r547007117,547007117,src/crypto/muhash.h
fjahr,2020-12-22 00:56:08,"Thanks, I have split up the large commit into four separate ones and melted the other unit test commit with one of them. I think this will help with reviews.",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r547007156,547007156,configure.ac
elichai,2020-12-22 11:03:20,"Is this really what we want?\nor do we want it to normalize it (like Finalize does) and then just serialize the numerator?",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r547213514,547213514,src/crypto/muhash.h
Sjors,2020-12-22 11:26:13,That might be a good idea. If we want to use MuHash in combination with assumeutxo then the shorter the (marginally) better.,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r547223670,547223670,src/crypto/muhash.h
Sjors,2020-12-22 11:28:27,"It should make it less likely for a future user of `Num3072` to shoot themselves in the foot, by calling `Divide(a)` and using `a` afterwards. ",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r547224730,547224730,src/crypto/muhash.h
fjahr,2020-12-22 21:36:34,"Right, that would be nicer and I had implemented it like that a few weeks ago but decided to kick it out again because code-wise it felt awkward to force normalization before every serialization. Maybe there is a better way to do it than what I tried code-wise. I don't think I found another example of where something comparable is done IIRC. Overall, normalizing is an expensive operation that woul",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r547518507,547518507,src/crypto/muhash.h
elichai,2020-12-23 10:55:07,"it depends, if we ever add a commitment to this in the coinbase or something like that then we might want to also save the MuHash in the undoBlocks.\nBut I think there's no point in discussing this now, so IMO you can leave it as-is",https://github.com/bitcoin/bitcoin/pull/19055#discussion_r547899299,547899299,src/crypto/muhash.h
hebasto,2021-01-21 18:18:48,typo: wether -> whether ,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r562098872,562098872,src/crypto/muhash.cpp
fjahr,2021-01-21 21:43:23,Thanks! Included a fix in #19145 ,https://github.com/bitcoin/bitcoin/pull/19055#discussion_r562216486,562216486,src/crypto/muhash.cpp
