gmaxwell,2014-05-25T08:33:58Z,"One way to test the latency is just to use the ping rpc (then getpeerinfo to see the results) and have a node with this patch and a peer with the patch. The effect should be visible (at least, it's very visible if you simply reset adjust the sleep!).\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44125582,44125582,
ashleyholman,2014-05-25T11:05:09Z,"**Test Results**\n\nTwo nodes were running, peered with each other via localhost, both running the same code.  For each test, 100 pings were generated.\n\n_TEST 1_: Unpatched master branch\nAverage ping time: 101ms\nMedian: 101ms\nStd Dev: 1.19ms\n\n_TEST 2_: Patched with no_sleep branch\nAverage ping time: 12.6ms\nMedian: 10.9ms\nStd Dev: 6.4ms\n\nImplementing the semaphore shows a clear drop in ",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44128384,44128384,
laanwj,2014-05-25T14:02:18Z,"If it doesn't seem related to your own code, the error in pulltester could be an intermittent one.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44133889,44133889,
ashleyholman,2014-05-25T14:33:37Z,Pushed an amended commit trigger the test again\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44134549,44134549,
ashleyholman,2014-05-26T02:47:38Z,"The test has failed twice now.  There must be a bug in this patch.  I did notice when doing my ping test that the nPingTime value would only update about 30% of the time.  But without the patch, it updated every time.  At the time, I thought this must have been some race condition in the ping code, which gets more pronounced with the lower ping time.  But now I'm thinking that perhaps it's droppin",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44153555,44153555,
mikehearn,2014-05-26T16:38:24Z,The end of the log says:\n- /mnt/bitcoin/qa/rpc-tests/wallet.sh /mnt/bitcoin/linux-build/src\n  Generating test blockchain...\n  Timeout: aborting command ``/mnt/bitcoin/qa/pull-tester/pull-tester.sh'' with signal 9\n\nSo you could try running that test script and see if it has issues.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44203272,44203272,
theuni,2014-05-26T19:33:55Z,"This seems like a scary change to make since it means that the messenger could stall if a post is forgotten.\nAs a means of easing into this, how about teaching CSemaphore something like timed_wait(), which would timeout at 100msec as before, or immediately wake when signaled?\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44213182,44213182,
ashleyholman,2014-05-27T01:01:01Z,"@theuni - I agree with you there.  However first I would like to get the timerless version working perfectly without any known bugs, and then add the 100msec timeout as pure safety net.  If it relies on the timer for normal function, then the patch hasn't really achieved its purpose.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44226801,44226801,
theuni,2014-05-27T15:13:10Z,"@ashleyholman Agreed, good plan.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44289688,44289688,
sipa,2014-05-31T11:58:24Z,"I think you want a condition variable here, not a semaphore. Calling post() twice means wait() will return twice on a semaphore, which we don't want.\n\nNote that CSemaphore is implemented on top of boost condition variables.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44746404,44746404,
ashleyholman,2014-05-31T12:51:33Z,"@sipa Ah, that is exactly the problem I've been wanting to solve. I basically need the semaphore's counter to reset to 0 when wait() returns. Should I be adding a new class to sync.h for that just does this?\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44747493,44747493,
sipa,2014-05-31T13:39:28Z,@ashleyholman What you really need is a condition-variable protected timestamp of the last addition to the receive queue or send state.\n\nBasically:\n\n```\nboost::mutex cs_condMessageHandler;\nboost::condition_variable condMessageHandler;\nint64_t nMessageHandlerLastUpdate;\nint64_t nMessageHandlerLastCheck;\n\nvoid MessageHandlerWaiter() {\n    boost::unique_lock<boost::mutex> lock(cs_condMessa,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44748561,44748561,
sipa,2014-05-31T13:50:57Z,"Ugh, instead of the two timestamps you could just have a single boolean too, set to true when updating, and set to false after returning from wait.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44748811,44748811,
sipa,2014-05-31T17:46:41Z,"To deal better with the ping latency variance, we could add a timestamp to CNetMessage, filled in when it is received. It's probably also useful for auto-disconnect logic of slow peers (currently, it's possible the trigger it if we're just too slow to react to an incoming message too).\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44754719,44754719,
ashleyholman,2014-06-01T04:14:13Z,@sipa do you think there should be a new class added to sync.h with a simple interface for this?  or just implement it all in the thread message handler?\n\nCould be something like\n\nvoid CCondition::wait()\nvoid CCondition::timed_wait(int milliseconds)\nvoid CCondition::post()\n\nSomething else that would be nice to have is a global message queue for new messages that need to be processed.  So r,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44767186,44767186,
sipa,2014-06-01T06:44:18Z,"On Jun 1, 2014 6:14 AM, ""Ashley Holman"" notifications@github.com wrote:\n\n> @sipa do you think there should be a new class added to sync.h with a\n> simple interface for this? or just implement it all in the thread message\n> handler?\n> \n> Could be something like\n> \n> void CCondition::wait()\n> void CCondition::timed_wait(int milliseconds)\n> void CCondition::post()\n\nPerhaps, but you have t",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44769051,44769051,
ashleyholman,2014-06-01T10:02:17Z,@sipa how is this?  uses a class to encapsulate the mutex + boolean flag + timeout.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44773333,44773333,
sipa,2014-06-01T10:55:09Z,"This segfaults for me during tests, because condMessageHandler is not necessarily initialized in those.\n\nHow about not making it a pointer, so it's initialized together with other global variables at startup?\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44774756,44774756,
ashleyholman,2014-06-01T11:17:28Z,Done.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-44775178,44775178,
ashleyholman,2014-06-04T15:54:26Z,"I've reliased that changing the frequency of ThreadMessageHandler's loop has implications on the ""trickle"" activity.  The trickling is designed around sending messages to 1 trickle node every 100 ms.  To make the message handling real-time without effecting the trickling, should these be split into 2 separate threads?\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-45109372,45109372,
ashleyholman,2014-06-04T16:00:54Z,"Or, it could just track the last time it trickled, and use this to determine whether to assign a trickle node or not for that iteration.  This, combined with a 100ms sleep timeout, should keep the behaviour the same.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-45110190,45110190,
laanwj,2014-07-08T07:51:16Z,"Looks good to me, going to test this.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48282008,48282008,
ashleyholman,2014-07-08T08:42:55Z,"@laanwj good to hear :).  I'm also looking for thoughts on handling the trickle behaviour as per my comments above.  I think in its current state, the patch will not trickle at the same rate.  The two options I could think of were either having a separate thread for trickling, or tracking a ""last trickle"" timestamp in ThreadMessageHandler and using that to calculate how long to do the timed_wait()",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48286183,48286183,
laanwj,2014-07-08T09:52:29Z,"To me, splitting it into two different threads sounds like the cleanest and least brittle solution here. A trickle thread that does its operations exactly every 100ms, and a message handler that wakes up only when necessary. After all, these are different concerns.\n\nAt some point we could switch to an async framework with deadline timers and such for the P2P code so that it can all be handled in",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48292633,48292633,
sipa,2014-07-08T18:07:41Z,"I marked this as a milestone for 0.10. Reducing propagation latency is very essential imho, and just shaving off ~40ms on average for every hop is huge.\n\nRegarding trickling: I think we don't nearly need 100ms intervals for that. How about once every 5s?\n\nI'm not sure about every other processing happening in SendMessages, but a few seconds doesn't sound too bad. \n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48377434,48377434,
sipa,2014-07-08T18:15:56Z,Just had a look at how frequently addr messages are effectively trickled out on bitcoin.sipa.be... turns out to be one every few seconds.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48378520,48378520,
ashleyholman,2014-07-08T20:48:53Z,"There is some analysis of the trickling code in this paper: http://arxiv.org/pdf/1405.7418.pdf in the ""Address propagation"" and ""Transaction propagation"" sections.  Based on this paper and also reading the code, I think there might be a potential to impact transaction propagation times if the trickle interval were increased.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48397577,48397577,
ashleyholman,2014-07-09T00:52:27Z,"More specifically, when a transaction is received, it has a 25% chance of being relayed to all peers immediately upon first call to SendMessages().  The other 75% of transactions will be delayed and pushed into the vInvWait queue which will only be sent to each peer when they are randomly chosen as the trickle node.  So as a transaction propagates through the network, there might be some unlucky n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48417855,48417855,
ashleyholman,2014-07-09T11:33:41Z,"Just pushed a new patch which splits the trickle activity into its own thread.\n\nI've kept the 100ms MilliSleep in this thread, but can change that if required.\n\nNote that the ThreadMessageHandler code currently causes a potential deadlock warning (Not introduced by this pull, but already there in master - reported in #4493).  Since this patch makes ThreadMessageHandler() fire more often, it co",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48458611,48458611,
mikehearn,2014-07-09T12:01:37Z,I'm not totally convinced that this trickle behaviour is worth it. Performance is super critical for happy users and the trickle seems to be intended to make it harder to track the flow of transactions across the network. But:\n- It's quite feasible to just connect to all publicly reachable nodes and watch propagation this way\n- Government level adversaries would be unlikely to be impacted by tim,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48460880,48460880,
laanwj,2014-07-09T12:33:48Z,"NACK on removing it. It is a sensible precaution. With the payment protocol, which is the way forward, the payer gives the merchant the transaction through a direct channel so propagation time through the network is not important for user experience.\n\nGoing to test this new version of the pull.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48463601,48463601,
gavinandresen,2014-07-09T13:00:07Z,Simplicity is better than complexity-- I vote remove it.\n\nThe trickle code was implemented before we supported running over Tor; Tor is a much better (but still not foolproof) way to get more private transactions.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48466193,48466193,
ashleyholman,2014-07-09T23:49:34Z,I have done an audit to find events that should require SendMessages() to run:\n- CNode::fPingQueued set (ping())\n- CNode::vAddrToSend pushed (CNode::PushAddress())\n- CNodeState::fShouldBan set (Misbehaving())\n- CNodeState::rejects pushed (InvalidBlockFound())\n- CNode::fStartSync set (StartSync())\n- CNode::vInventoryToSend pushed (CNode::PushInventory())\n- CNodeState::nBlocksInFlight decreas,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48549858,48549858,
ashleyholman,2014-07-10T00:40:02Z,Pros of removing trickling:\n- Faster transaction propagation (All peers blast the tx 100% of the time)\n- Simpler to understand code\n\nCons of removing trickling:\n- Reduced privacy for non-tor users\n- Increased burst of inv messages across the network may consume more bandwidth\n- Increased risk from changing protocol behaviour\n\nThis paper is worth a read for anyone who hasn't read it: http:,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48553076,48553076,
laanwj,2014-07-10T06:23:43Z,"@ashleyholman Thanks for the work on analyzing the network code! Maybe an intermediate solution, as long as cs_main is still needed for some actions, would be to do a timed wait only when it failed to acquire the lock, and a non-timed wait otherwise?\n\nLet's move the discussion about moving or not removing trickle to the mailing list. Don't combine major behaviour changes with refactoring. Having",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48569329,48569329,
ashleyholman,2014-07-10T08:12:51Z,"> Maybe an intermediate solution, as long as cs_main is still needed for some actions, would be to do a timed wait only when it failed to acquire the lock, and a non-timed wait otherwise?\n\n@laanwj That sounds good.  It could at least do a shorter timed wait when the lock failed, and a longer one when it succeeds.  The longer one is needed so that it can still do stalled peer detection.  However,",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48576439,48576439,
laanwj,2014-07-10T09:43:06Z,"I think if it failed to acquire the lock for at least one peer, it needs a timed re-try.\n\nIn principle it is really inefficient that it has to acquire the lock many times, but that's harder to solve.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48584487,48584487,
ashleyholman,2014-07-10T11:15:54Z,"It could perhaps acquire the lock once before the SendMessages loop.  That way, all the SendMessages calls will succeed on the locks.  I don't think the message handler currently spends much time without the lock anyway.\n\nThe only difference is that there wouldn't be a gap inbetween calls for other threads to obtain cs_main.  If that's a problem, it could perhaps acquire the lock, then do SendMe",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48591992,48591992,
ashleyholman,2014-07-10T11:19:47Z,"Coincidentally, that would fix the potential deadlock issue as well.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48592310,48592310,
ashleyholman,2014-07-10T12:22:55Z,My latest patch implements some more trigger points to wake up ThreadMessageHandler.  This covers off on all cases I can identify where messages need to be sent.\n\nI've also removed the dependence on util.h.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48597286,48597286,
laanwj,2014-07-10T12:26:19Z,"@ashleyholman Indeed - the intent behind releasing the main lock once in a while is to give other threads a chance. For example the GUI can appear to hang on some actions if the main lock is held for too long. I'm not sure if the network thread will hold the lock for long, though. The longest main-lock holders have always been wallet rescanning and some block processing.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48597550,48597550,
sipa,2014-07-10T12:28:53Z,"I think we should pushing cs_main down, not up.\n\nThe whole reason for worrying about it is because the validation logic\nlocks cs_main for very long times, so we need workarounds for dealing with\nit.\n\nAlso, this code should not cause a deadlock:\n- thread 1: lock(a) ... lock(b)\n- thread 2: lock(b) ... try_lock(a)\n\nThe typical deadlock scenario would be 1 acquiring a, 2 acquiring b,\nfollow",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48597773,48597773,
ashleyholman,2014-07-10T12:34:16Z,"@sipa I concur.  It does produce a ""potential deadlock"" warning though, because I guess the deadlock detection doesn't know that the 2nd lock is conditional on try_lock().\n\nWhat I mean about ThreadMessageHandler is that I think it already spends most of its _waking_ time with cs_main, but agreed that its not much time overall.  So if it acquired cs_main upon wakeup and freed it before sleeping, ",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48598257,48598257,
ashleyholman,2014-07-10T12:47:24Z,"To be clear about the change I'm describing:\n- Make cs_main a precondition for calling SendMessages()\n- Remove the TRY_LOCK / early return logic from SendMessages.  It now does all work required of it, guaranteed.\n- Acquire cs_main in ThreadMessageHandler, prior to calling SendMessages().\n- The above acquisition of cs_main can be batched to hold cs_main for many invocations of SendMessages() (",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48599457,48599457,
ashleyholman,2014-07-10T13:32:08Z,"Just got another idea.. what about splitting SendMessages into two separate functions.  One that requires cs_main and one that doens't.  Most work can go into the non-lock one, eg. ping, inv, and addr messages.  The cs_main function will be responsible for the other parts that need the lock, the most important of these being getdata messages which impact block propagation time.\n\nI'm still sugges",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48604211,48604211,
ivanpustogarov,2014-07-10T16:36:05Z,We think that removing trickling will definitely make Bitcoin less anonymous for non-Tor users. The attack has three (independent) parts:\n1) Linking a user's IP address to his entry nodes (his 8 outgoing connections). Possible only if Tor is not used.\n2) Correlating transactions to entry nodes.\n3) Linking together transactions of the same user  during one session.\n\nThe trickling delay for 75%,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48629839,48629839,
laanwj,2014-07-11T13:02:24Z,"@ivanpustogarov I agree, but as said please move the trickling discussion to the mailing list, removing trickling is off the table in this pull.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48727210,48727210,
ashleyholman,2014-07-12T05:28:31Z,"@sipa @laanwj Please take a look at my latest commit if you get a chance.  It's doing what I described above - splitting SendMessages() into two functions and requiring the lock for one of them.\n\nThere is the potential to move the sending of non-block getdata messages into the lockless function, but that would cause 2 getdata messages to be sent (1 getdata for blocks, another getdata for non-blo",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48802954,48802954,
sipa,2014-07-12T16:00:02Z,"Adding a SendMessagesCSMain seems wrong from a design point. Main is a _client_ of net, registering some handlers to be called when certain events occur. If there are some parts of SendMessages logic that do not rely on cs_main, that means that code shouldn't have been in main in the first place. And net certainly shouldn't know about or use cs_main itself.\n\nHow about moving the non-cs_main-depe",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48816062,48816062,
ashleyholman,2014-07-12T19:39:28Z,"@sipa Thanks for checking it out.  It felt like a kludgy hack as I was doing it, but I wanted to get the concept into code.  That sounds like a much better way to do it.  As for having two handlers on SendMessages, I don't know how I would be able to batch up the cs_main-dependent work to run under one acquisition of the lock.  I'd have to acquire cs_main inside the main.ccp SendMessages handler, ",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48821888,48821888,
sipa,2014-07-12T20:09:37Z,"I think we should just get the lock once per peer, and if necessary, move the acquiring of the sender or receiver node lock inside sendmessages too, if the ordering of locks requires that.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48822675,48822675,
ashleyholman,2014-07-13T00:34:00Z,I've reverted my previous two commits and pushed a new patch with the cleaner design.  cs_main is now acquired inside SendMessages() for each peer.  Note that SendMessages() now waits to acquire cs_main instead of returning when TRY_LOCK fails.  I think this will result in lower latency since it doesn't delay messages till the next ThreadMessageHandler iteration.\n\nedit: moving the send receive l,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48828027,48828027,
ashleyholman,2014-07-13T03:42:35Z,"I think this pull is ready for a closer review now, so I've pushed a fresh rebase and squashed everything into a single patch.\n\nThanks.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48830853,48830853,
sipa,2014-07-14T20:13:29Z,"Testing.\n\nNeeds a rebase, though.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48953279,48953279,
ashleyholman,2014-07-14T21:56:59Z,Rebased.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48965491,48965491,
sipa,2014-07-16T15:21:10Z,"We may need a separate per-node lock now for the fields used by the non-main message handler thread code, as otherwise for example the ping variables may be accessed by both the trickle and normal handler thread?\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-49181296,49181296,
ashleyholman,2014-07-16T21:45:45Z,SendMessagesNet locks pto->cs_vSend (node-specific lock) before it checks the ping flag and inventory list.  So I think that should exclude the two threads from racing?\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-49231937,49231937,
sipa,2014-07-16T21:52:35Z,"But ProcessMessage (which also accesses those variables) does not lock cs_vSend. The regular message handler can be running ProcessMessage, while the trickle thread is running SendMessages.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-49232712,49232712,
ashleyholman,2014-07-16T21:57:51Z,"ProcessMessages() is only called by ThreadMessageHandler, and it locks the node's cs_vRecvMsg before calling it.  In ThreadTrickle it's only doing sending because that's the only part that uses the trickle flag.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-49233315,49233315,
sipa,2014-07-16T22:00:47Z,"So? What prevents ThreadMessageHandler -> ProcessMessages -> ProcessMessage -> ""pong"" from running simultaneously with ThreadTrickle -> SendMessages -> ""ping"" ?\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-49233655,49233655,
ashleyholman,2014-07-16T22:03:44Z,"Ahh yes, I get it now.  Sorry.  Any suggestions on naming this new lock?\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-49233985,49233985,
ashleyholman,2014-08-10T08:27:05Z,"I have added a new lock, CNode::cs_ping, to protect the race condition in the ping/pong processing.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-51709229,51709229,
sipa,2014-08-10T09:47:41Z,"Untested ACK (and testing right now). I would abstract all the condMessageHandler.notify_one() calls behind a function in net, though.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-51710514,51710514,
ashleyholman,2014-08-10T12:02:42Z,Replaced all message handler notifications with WakeMessageHandler().\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-51712924,51712924,
ashleyholman,2014-08-24T08:32:43Z,Does anyone need anything further from me on this?  I need another ack on it.  How about @laanwj since you have had some involvement?\n\nI'll need to do one final squash/sign before the merge.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-53183913,53183913,
sipa,2014-08-24T19:55:20Z,Tested ACK.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-53204863,53204863,
BitcoinPullTester,2014-08-25T11:40:27Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4230_5eef5a482ce8be3c4d34605bf2dc1e57c5b4bb55/ for binaries and test log.\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-te",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-53253739,53253739,
sipa,2014-08-27T20:00:32Z,Needs rebase.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-53631614,53631614,
BitcoinPullTester,2014-08-28T10:20:53Z,"Automatic sanity-testing: FAILED MERGE, see http://jenkins.bluematt.me/pull-tester/p4230_eebbb0be605d37e9a4dd5079695ab59258886f67/ for test log.\n\nThis pull does not merge cleanly onto current master\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.lo",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-53701833,53701833,
ashleyholman,2014-08-28T11:24:25Z,Rebased and squashed.  Let me know if you need anything else!\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-53707162,53707162,
BitcoinPullTester,2014-08-28T11:26:32Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4230_fe5491a91d7e500df90ef1d69bdc3d5dbabc6dc9/ for binaries and test log.\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-te",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-53707313,53707313,
BitcoinPullTester,2014-08-28T12:08:41Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4230_81da9c77b5e9a93fe2687061f68c29e0b94f36eb/ for binaries and test log.\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-te",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-53710947,53710947,
BitcoinPullTester,2014-08-31T10:21:49Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4230_c75bae764b936fde9d691bbe39115286d486ad61/ for binaries and test log.\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-te",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-53983705,53983705,
BitcoinPullTester,2014-09-02T10:00:58Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4230_28a7464bb7e851800c4924162ecd9d1ec5961288/ for binaries and test log.\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-te",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-54131314,54131314,
sipa,2014-09-05T21:19:31Z,@laanwj @gmaxwell @jgarzik Care to review/test this?\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-54682909,54682909,
gmaxwell,2014-09-05T21:22:06Z,I'm on it now. Thanks for the heads upâ€” this fell off my radar after the initial issues. Thanks for your patience @ashleyholman.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-54683188,54683188,
laanwj,2014-09-06T02:44:28Z,"I've been testing this for quite a while time already, no problems. ACK.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-54700220,54700220,
sipa,2014-09-08T17:24:06Z,"Just did a (almost) full resync from this + #4834 as (one of the servers), with #4468 + #4834 as client. No problems, and the client reports low (~30ms) ping latencies during sync for that server.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-54855111,54855111,
gmaxwell,2014-09-08T22:27:30Z,"I've had this running in valgrind for few days and run it through some paces, e.g. bouncing connections, flooding it with inbound connections and messages... Seems to be holding up well. Hurray.\n\nI'm somewhat concerned with peppering the code with wakeups. It's not always clear where they're needed and why, and I worry that if a future patch adds code that needs a wake that it will be missed. Is",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-54896946,54896946,
ashleyholman,2014-09-09T08:43:58Z,"The wakeups were placed according to an audit I did, [detailed in this comment](https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-48549858).  I was looking for places in the code that changed any state that would cause new messages to send next time SendMessages() runs.  But upon thinking about this further, most of the times when that state is changed, it's happening during ProcessMessage",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-54940551,54940551,
sipa,2014-09-09T15:00:55Z,"I would leave the trickle as a separate thread (it's some extra memory, but it's a simple to understand model), and moving part of the protocol handling out of main is also nice.\n\nIf every processmessage call is followed by a sendmessage call, I would suggest removing the Wake calls in the processmessage path (note that ActivateBestChain is also only called from within ProcessMessage...). Are th",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-54982253,54982253,
sipa,2014-09-09T18:58:17Z,"Undo ACK.\n\nI missed something. The trickle thread will call SendMessages with fSendTrickle, but all non-trickle behaviour therein will also run. This means many more data structures that are potentially accessed from multiple threads (just saw a use-after-reallocate in valgrind).\n\nIf we need the trickle thread, I would suggest creating a new entry in CNodeSignals for the trickling, and for han",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-55016474,55016474,
ashleyholman,2014-09-09T19:41:51Z,"For some reason I thought ActivateBestChain() would have been called from another thread that does block validation.  But still, I'm still thinking it requires the wakeup because it needs to send a messages to _all_ peers.  We can only guarantee that SendMessages is going to run for the _current_ peer who sent the block, plus any other peers that come after it in the vNodes list.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-55022122,55022122,
ashleyholman,2014-09-15T10:50:48Z,"@sipa:  SendMessages in main is locking pto->cs_vSend, so shouldn't that prevent two threads from running it concurrently for the same CNode?  SendMessagesNet does the same with pto->cs_vSend.\n\nThe only potential concurrency I can see from code outside of those functions is with access to CNode::vAddrToSend.  There are a few places that are either accessing vAddrToSend directly, or using PushAdd",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-55575435,55575435,
ashleyholman,2014-10-13T20:08:25Z,"I'm ready to give this some attention again.  It feels like it is close, so it would be good to try to get it over the line and integrated.  The only issue I am aware of is the race condition identified by @sipa.  If there needs to be significant refactoring to deal with this then let me know.  Otherwise if there's some simpler way to fix it then that would be good, considering all the testing tha",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-58947365,58947365,
sipa,2014-10-13T21:00:10Z,"Independently, I would really prefer to see a separate Trickle handler, where the trickle behavior and nothing else runs, from the trickle thread. It's hard enough to reason about the correctness already.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-58954035,58954035,
gmaxwell,2014-10-13T21:03:36Z,"I'd really like to see this get in soon, but I'm still uncomfortable with the manual wakeups, which I think we'll never manage to keep updated correctly.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-58954463,58954463,
laanwj,2014-10-18T09:13:11Z,"Moved the milestone to 0.11 -  I agree this should get in, but this is not ready yet, and a high-impact network code change like this needs some time to be tested in master after being merged.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-59604360,59604360,
gmaxwell,2014-10-20T18:58:00Z,@laanwj   I think we were thinking that its possible to achieve this with a much smaller and simpler diff (e.g. one that wakes immediately on recieved but still polls so that we're sure it's safe with no sprinkled wakeups).\n\nI think this delay is currently the biggest latency source for block propagation on the network.\n,https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-59820927,59820927,
laanwj,2015-03-18T12:58:31Z,"This pull has been inactive for almost 6 months. \nWould be great if someone picked this up, but as there isn't enough confidence in this implementation as-is, and thus it won't merged in this state, I'm closing the pull.\n@ashleyholman let me know if you intend to work on this again, I'll reopen.\n",https://github.com/bitcoin/bitcoin/pull/4230#issuecomment-82958459,82958459,
laanwj,2014-07-10T07:10:04Z,I'd like to avoid introducing this include-file dependency if possible\n,https://github.com/bitcoin/bitcoin/pull/4230#discussion_r14752023,14752023,src/sync.h
laanwj,2014-08-25T07:39:14Z,Due to using relative durations there's a slight window for a race condition here:\n- `boost::posix_time::microsec_clock::universal_time()` called the first time in the while() clause and returns a value `< alarm`\n- `boost::posix_time::microsec_clock::universal_time()` called the second time in the subtraction returns a value `> alarm`\n  In this case either a negative value would be passed to ti,https://github.com/bitcoin/bitcoin/pull/4230#discussion_r16644924,16644924,src/sync.h
ashleyholman,2014-08-25T11:30:01Z,I just pushed a patch which changes it to use the absolute version.  I tested and it is still waking up after 1 second as expected.\n,https://github.com/bitcoin/bitcoin/pull/4230#discussion_r16650952,16650952,src/sync.h
sipa,2014-08-26T14:17:53Z,"An alternative:\n\n```\nauto now = boost::posix_time::microsec_clock::universal_time();\nalarm = now + boost::posix_time::milliseconds(milliseconds);\nwhile (!fHasWork && now < alarm) {\n    condition.timed_wait(lock, alarm);\n    now = boost::posix_time::microsec_clock::universal_time();\n}\nfHasWork = false;\n```\n",https://github.com/bitcoin/bitcoin/pull/4230#discussion_r16715585,16715585,src/sync.h
ashleyholman,2014-08-28T09:54:47Z,"I suppose that will mean one less call to boost::posix_time::microsec_clock::universal_time(), so I will use that.\n",https://github.com/bitcoin/bitcoin/pull/4230#discussion_r16830203,16830203,src/sync.h
Diapolo,2014-08-28T21:50:37Z,"Nit: As this is a function, can you start with `{` in the next line?\n",https://github.com/bitcoin/bitcoin/pull/4230#discussion_r16870198,16870198,src/net.cpp
ashleyholman,2014-08-31T09:58:56Z,Pushed a new patch with the brace moved.\n,https://github.com/bitcoin/bitcoin/pull/4230#discussion_r16933897,16933897,src/net.cpp
TheBlueMatt,2014-09-02T06:44:54Z,Why not push this conditional to the end with the other one?\n,https://github.com/bitcoin/bitcoin/pull/4230#discussion_r16972194,16972194,src/net.cpp
ashleyholman,2014-09-02T09:47:30Z,Done\n,https://github.com/bitcoin/bitcoin/pull/4230#discussion_r16978428,16978428,src/net.cpp
