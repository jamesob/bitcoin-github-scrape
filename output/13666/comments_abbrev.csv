luke-jr,2018-07-15T06:02:01Z,Does this reduce the entropy of the nonce? To what degree?,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405069592,405069592,
sipa,2018-07-15T06:04:03Z,@luke-jr By around 1.0226 bits.,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405069682,405069682,
sipa,2018-07-15T18:23:25Z,"utACK af049b2b52a93dcd05a78c381510534b0c52b4de\n\nI believe there are no downsides to this, except for making the signing time double on average. It reduces the entropy in the nonce slightly, but not in a way that is usable to an attacker as far as I can tell.\n\nComments, @gmaxwell, @apoelstra ?",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405108732,405108732,
gmaxwell,2018-07-15T20:38:58Z,"It seems weird-- wasteful and needlessly more identifiable-- to not emit a smaller signature when one shows up. That seems like a bad idea to me. Why not just check that the R size is <=32 bytes? Sometimes you'll be smaller and 'overpay' fee-- yes, but you'll at least get extra priority for your cost. If you instead throw out that candidate signature, you'll still pay the same, but not get the imp",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405116700,405116700,
sipa,2018-07-15T20:44:20Z,"> I see no security problem from doing this, though the grinding could made ~3x faster by using the endomorphism.\n\nI believe that doing so would introduce an (additional) bias in the resulting nonce. For example, in groups of 3 points related by multiplication by beta, if only two are low-R, one will be chosen 2/3rd of the time, and the other will be chosen 1/3rd of the time. I don't see a way",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405117023,405117023,
achow101,2018-07-16T18:46:14Z,I have changed this to allow signatures less than 71 bytes and fixed/added tests for this.,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405342204,405342204,
sipa,2018-07-16T23:03:12Z,utACK 9b7e6e9f0efc74d4f1576802494b5b7966699949,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405407454,405407454,
gmaxwell,2018-07-17T16:36:43Z,"You should also change DummySignatureCreator() and all the comments in wallet.cpp talking about the dummy signatures being 72 bytes,  no?",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405646885,405646885,
sipa,2018-07-17T21:46:46Z,@gmaxwell The change to DummySignatureCreator is already included here.,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405738848,405738848,
gmaxwell,2018-07-18T00:36:06Z,"Hm. Weird, I see it now, dunno why I missed it before.",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-405771690,405771690,
gmaxwell,2018-07-18T19:06:14Z,ACK,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406040985,406040985,
achow101,2018-07-18T19:27:29Z,Rebased onto master and removed a psbt signing test that has a high R value (signing is still tested with the other test vector that has low R). Also updated comments in wallet.,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406046643,406046643,
JeremyRubin,2018-07-18T19:52:31Z,"Noting that the search is easily parallelizable without loss of determinism. With this, we can pretty comfortably ignore the overhead for most users.\n\nA separate concern is this makes hardware wallets more identifiable if this is difficult for them to implement.",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406053492,406053492,
gmaxwell,2018-07-19T00:56:53Z,"@JeremyRubin  each trial has a 50% probability of success the search tries 2 values on average, it wouldn't make sense to parallelize. :) and _should_ be okay for any hardware wallet.",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406119814,406119814,
JeremyRubin,2018-07-19T22:21:08Z,"If I'm not mistaken (my EC math knowledge isn't amazing), could you re-use (k X G) and k^-1 by doing the search via doubling rather than increment.\n\nSuppose\n\nk' = 2k, then k' x G = 2k x G = k x G + k x G\n\nnow k'^-1 = 2^-1 k^-1\n\n\nNot sure if this further reduces the entropy of the nonce too much, but the same optimization also eliminates an ec mul for k' = k+1.",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406432246,406432246,
sipa,2018-07-19T22:42:16Z,"@JeremyRubin That loses another 0.2885 bits of entropy (1 in 2^N nonces will have N times higher probability). Though in general, I'm really uncomfortable with anything but a uniform distribution (over a sufficiently large subset of acceptable values). See https://www.wolframalpha.com/input/?i=255+-+sum(i%2F2%5E256*log(i%2F2%5E256)*2%5E(255-i),i%3D1...infinity)%2Flog(1%2F2)",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406436369,406436369,
JeremyRubin,2018-07-20T01:42:54Z,"@sipa just k'=k+1 and eliminating an ec mul shouldn't lose any additional entropy, though not sure what percent of the compute time k'G is.\n\nIn general, I'm not sure it is worth it to lose any entropy for signature time, but .2885 isn't much (nor is the endomorphism thing @gmaxwell mentioned).\n\nI think it would be good to provide a strong rationale in this PR on exactly how much entropy is",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406463780,406463780,
sipa,2018-07-20T01:54:31Z,"@JeremyRubin Using `k' = k + 1` has the same loss of entropy. For example if a particular nonce k has a corresponding low-R, and the 6 nonces before it (k-6...k-1) all have high-R, then that nonce has 7 times more chances to be chosen than one where k-1 is also low-R.\n",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406465410,406465410,
sipa,2018-07-20T01:57:15Z,"> for instance if we infer that it took 10 signature attempts (which should happen once in 1024 attempts), we reduce the nonce space for that message by 1/1024.\n\nYes, indeed. Information theoretically this is a leak. But the only way an attacker can find out whether a particular nonce is in that subset of 1/1024 is by doing 10 EC multiplications on the preceeding nonces... the exact operation ",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406465786,406465786,
achow101,2018-07-20T02:03:08Z,"> I think it would be good to provide a strong rationale in this PR on exactly how much entropy is tolerable to drop (e.g. why 1.0226 bits is OK and not 1.3111 bits). Dropping any entropy seems like a non-starter to me.\n\nThe actual entropy loss is 1 bit exactly. The 0.0226 comes from a previous version of this PR where all signatures had to be 71 bytes. With that now removed, only 1 bit of ent",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406466702,406466702,
JeremyRubin,2018-07-20T03:48:33Z,"@sipa ah thanks, they key information I was missing was that the counter goes through a hash (it's not just directly put on the curve).",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406481150,406481150,
Sjors,2018-07-20T11:49:01Z,"Should there be an informational BIP for this to make it more likely other wallets do the same? Any feedback on that BIP might have to wait for the next release to be implemented, but perhaps some obvious problem is found in time.\n\nAt the same time, it might be useful to propose replacement test vectors for BIP-174, rather than deleting them. I'm sure you and the author get along well :-P\n\",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406577525,406577525,
sipa,2018-07-20T19:13:03Z,"@Sjors I think that's a good idea, actually. There are clearly several questions in this thread about which specific variant to use, and the trade-offs, so I think it would be good to have it written up somewhere. That would also make it easy to point to, or to have a write-up we can ask expert advice about.\n\nDoing so also gives us the opportunity to drop RFC6979 and favor of a faster construc",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406700712,406700712,
Sjors,2018-07-21T07:50:00Z,"I'd say there's two separate goals:\n\n1. Get more eyes on this specific change before it's irreversible (e.g. it could be merged, but removed from a 0.17rc)\n2. Come up with an even better approach for a future next release (can blend in with whatever coin selection changes are ready then)\n\nSo maybe hold off on the BIP and just drop a summary of this thread on the bitcoin-dev list?",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406778593,406778593,
gmaxwell,2018-07-21T17:39:46Z,"This isn't really very important one way or another,  but I think it's not good for the project that every single little thing takes forever for no obvious reason.   There isn't anything meaningful that would change about this-- sure, someone might optimize it further by not using 6979 or whatnot, but at the end of the day instead of flipping a coin once, it flips it until it comes up tails. And a",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406812027,406812027,
sipa,2018-07-21T21:13:42Z,@gmaxwell That's fair; there is no observable difference between generating nonces one way or another as long as the success condition is the same (low R). I'm mostly wondering if people are ok with changing signatures once and then changing them again if/when there would be a more widely adopted standard.,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-406823907,406823907,
maaku,2018-07-23T19:08:28Z,I am not in favor of this change. It would add a way of (statistically) differentiating Bitcoin’s wallet from other signers  and it is unlikely that all implementations will switch to this scheme. In particular there are potential improvements that could be made to hardware wallets to export a bulletproof that the nonce was selected according to a specified deterministic algorithm. Adding addition,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-407167926,407167926,
gmaxwell,2018-07-26T19:24:54Z,"> I am not in favor of this change. It would add a way of (statistically) differentiating Bitcoin’s wallet from other signers\n\nOther changes in the current version make its transactions identifyable, so for the moment I think that concern is mostly moot. The expectation here is that other wallets would also adopt this change over time. This is the reason that it doesn't shave an additional byt",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-408207897,408207897,
Sjors,2018-07-27T09:06:02Z,"I wrote:\n> Grinding seems to ~ double the amount of data about the private key the wallet gives to a side-channel attacker.\n\nBut that's not true. Unlike when deriving a public key `Q = d × G`, where you could determine `d` by monitoring a device that performs this elliptic curve multiplication multiple times (with a not perfectly time-constant implementation ), for signatures the private key",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-408359557,408359557,
maaku,2018-08-02T23:15:04Z,"@gmaxwell wrote:\n\n> Unrelated, I'm not aware of any reason that the sign-2-contract fix for nonce sidechannels isn't just as effective as a BP... and it's actually computationally reasonable on existing hardware... and would still work with this approach.\n\nCan you expand on this? What ""sign-2-contract fix for nonce side channels""? It might be the case this is something you've explained to ",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-410096633,410096633,
sipa,2018-08-02T23:41:19Z,"@maaku \n\n* HW device generates a nonce `k` (deterministically from msg/privkey, or with real RNG).\n* HW device computes `R = kG` and sends it to host device.\n* Host device generates randomness `c` (possibly based on `R`), and sends it in plain text to HW device.\n* HW device computes `k' = H(R, c) + k` and `R' = H(R, c)G + R`, and uses those in the signature it produces.\n* HW device sen",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-410100771,410100771,
laanwj,2018-08-07T11:23:33Z,"One question I have here: With the PSBT work, would this affect potential usage of bitcoin core with hardware wallets that do not implement this specific trick and might still generate 72-byte signatures?",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-411023542,411023542,
sipa,2018-08-07T16:23:57Z,"@laanwj That's a good point. Perhaps we should still count the size of unknown signatures in DummySignatureCreator as 72 rather than 71, to account for the possibility that external signers produce 72 bytes?",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-411117029,411117029,
achow101,2018-08-07T16:47:57Z,"> Perhaps we should still count the size of unknown signatures in DummySignatureCreator as 72 rather than 71, to account for the possibility that external signers produce 72 bytes?\n\nI think that kind of defeats the purpose of this change. Since the DummySignatureCreator is only used for fee estimation of unsigned transactions, perhaps we could make it work so that it uses 72 bytes for inputs t",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-411124692,411124692,
achow101,2018-08-08T00:22:02Z,I pushed a commit that switches between 71 and 72 byte signatures depending on whether watching only inputs can be selected.,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-411243868,411243868,
DrahtBot,2018-08-08T05:07:20Z,<!--e57a25ab6845829454e8d69fc972939a-->Note to reviewers: This pull request conflicts with the following ones:\n\n* #13917 (Additional safety checks in PSBT signer by sipa)\n* #13723 (PSBT key path cleanups by sipa)\n* #13268 (Consistently bounds-check vin/vout access by Empact)\n* #11634 (wallet: Add missing cs_wallet/cs_KeyStore locks to wallet by practicalswift)\n\nIf you consider this pull req,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-411286719,411286719,
gmaxwell,2018-08-10T05:56:46Z,Re-ACK,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-411983318,411983318,
sipa,2018-08-10T22:31:47Z,utACK e306be742932d4ea5aca0ea4768e54b2fc3dc6a0,https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-412223265,412223265,
laanwj,2018-08-14T15:31:41Z,"@JeremyRobin commented the following:\n\n> I'm also curious if there's an opportunity to leak entropy out of this as a timing attack. If the attacker can make unlimited requests, they can clearly figure out the difference between a msg that (deterministically) takes one signing time and two signing times (or more) by making a historgram of the signing times. From there, they can figure out wheth",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-412913964,412913964,
sipa,2018-08-14T16:03:53Z,"We had a discussion about this on IRC with @gmaxwell and @JeremyRubin. While I think it would be good to document this reasoning, I'll summarize here:\n\n* RFC6979 itself specifies a very similar form of iteration to produce nonces, to make sure they are in the valid range (between 1 and the group's order). For secp256k1 this is not observable, as the order is so close to a power of 2 (2<sup>256",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-412925155,412925155,
junderw,2018-08-20T08:44:08Z,"Clarification request:\n\nRef: https://tools.ietf.org/html/rfc6979#section-3.2\n\nIn `3.2 d and f`. it states:\n\n```\nd:\nK = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1))\nf:\nK = HMAC_K(V || 0x01 || int2octets(x) || bits2octets(h1))\n```\n\nbut in the case where r is >= 2^255 we must re-try the RFC6979 k generation this time with the extra_entropy set to 1 (since when count",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-414242714,414242714,
amiwrcd,2019-01-29T11:45:23Z,"> We had a discussion about this on IRC with @gmaxwell and @JeremyRubin. While I think it would be good to document this reasoning, I'll summarize here:\n> \n> * RFC6979 itself specifies a very similar form of iteration to produce nonces, to make sure they are in the valid range (between 1 and the group's order). For secp256k1 this is not observable, as the order is so close to a power of 2 (225",https://github.com/bitcoin/bitcoin/pull/13666#issuecomment-458510738,458510738,
sipa,2018-07-15T05:26:53Z,Why are these tests changing?,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r202531735,202531735,src/test/data/script_tests.json
achow101,2018-07-15T05:50:17Z,"I assume that they are changing because they are signatures produced with an extra entropy value of 0 (provided by the test case, not the signing method). However in the signing method, an entropy value of 0 has the same meaning as no extra entropy provided which means that the signature will be ground for low R. So in order to get high R, the extra entropy value will need to increment so that a h",https://github.com/bitcoin/bitcoin/pull/13666#discussion_r202532071,202532071,src/test/data/script_tests.json
sipa,2018-07-15T05:57:50Z,"Perhaps you should split up the signing method into a grinding and a manual one, so the tests can keep creating the old method with provided entropy rather than grindjng?",https://github.com/bitcoin/bitcoin/pull/13666#discussion_r202532185,202532185,src/test/data/script_tests.json
achow101,2018-07-15T07:30:37Z,I changed it to have a grind boolean to indicate whether grinding should be used. This results in those tests not changing now.,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r202533893,202533893,src/test/data/script_tests.json
sipa,2018-08-08T00:05:13Z,"You can write this much more compactly using a conditional\n```\nIf (ProduceSignature(*this, use_max_sig ? DUMMY_MAXIMUM_SIGNATURE_CREATOR : DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata)) {\n```",https://github.com/bitcoin/bitcoin/pull/13666#discussion_r208421727,208421727,src/wallet/wallet.cpp
sipa,2018-08-08T00:19:45Z,Why?,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r208423719,208423719,src/wallet/wallet.cpp
sipa,2018-08-08T00:20:08Z,Variable naming style nit: `m_r_len`.,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r208423783,208423783,src/script/sign.cpp
achow101,2018-08-08T00:21:13Z,Done,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r208423917,208423917,src/wallet/wallet.cpp
sipa,2018-08-08T00:22:58Z,"Maybe you can drop the default constructor, and just specify the actual sizes in for both instances?",https://github.com/bitcoin/bitcoin/pull/13666#discussion_r208424140,208424140,src/script/sign.cpp
achow101,2018-08-08T00:25:57Z,"Oops, forgot to remove some of my debugging stuff. Fixed",https://github.com/bitcoin/bitcoin/pull/13666#discussion_r208424547,208424547,src/wallet/wallet.cpp
achow101,2018-08-08T00:27:33Z,Fixed,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r208424765,208424765,src/script/sign.cpp
achow101,2018-08-08T00:27:39Z,Done,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r208424780,208424780,src/script/sign.cpp
kallewoof,2018-08-09T23:41:09Z,"In ""Always create 70 byte signatures with low R values"":\n\nA comment explaining why the first byte being ` < 0x80` means the signature has a low R would be useful, unless this is blindingly obvious to everyone else.",https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209110676,209110676,src/key.cpp
kallewoof,2018-08-09T23:49:32Z,"In ""Always create 70 byte signatures with low R values"":\n\nNit: `&=` unnecessary, can just use `=`, `ret` is always true (though compilers will most likely figure this out and optimize away).",https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209112084,209112084,src/key.cpp
kallewoof,2018-08-10T00:01:15Z,"In ""Use 72 byte dummy signatures when watching only inputs may be used "":\n\nI know this flag is used for watch-only outputs, but that's not what the flag is, it's a flag that uses the 72 byte dummy signature instead of the 71 byte one. Noting that this is enabled when output is watch-only is useful, of course.",https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209113859,209113859,src/wallet/wallet.h
achow101,2018-08-10T01:22:41Z,Done,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209123064,209123064,src/key.cpp
achow101,2018-08-10T01:22:48Z,Done,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209123079,209123079,src/key.cpp
achow101,2018-08-10T01:22:52Z,Fixed,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209123091,209123091,src/wallet/wallet.h
kallewoof,2018-08-10T01:25:42Z,Nit: `its signed-ness`,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209123389,209123389,src/key.cpp
kallewoof,2018-08-10T01:30:52Z,"Maybe overkill, but you could in theory do\n```C++\nwhile (secp256k1_ecdsa_sign(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, (counter || (!grind && test_case)) ? extra_entropy : nullptr)\n    && !SigHasLowR(&sig) && grind) {\n    WriteLE32(extra_entropy, ++counter);\n}\n```\nto replace\n\nhttps://github.com/bitcoin/bitcoin/blob/069c87957660adda970",https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209123964,209123964,src/key.cpp
achow101,2018-08-10T01:39:26Z,I'd rather not. It's kind of hard to read (at least to me).,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209125046,209125046,src/key.cpp
achow101,2018-08-10T01:40:09Z,Fixed,https://github.com/bitcoin/bitcoin/pull/13666#discussion_r209125099,209125099,src/key.cpp
